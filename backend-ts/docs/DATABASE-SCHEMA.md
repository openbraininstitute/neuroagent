# Database Schema Documentation

Complete documentation of the Neuroagent database schema, migrations, and best practices.

## Table of Contents

1. [Overview](#overview)
2. [Schema Structure](#schema-structure)
3. [Models](#models)
4. [Relationships](#relationships)
5. [Enums](#enums)
6. [Indexes](#indexes)
7. [Migrations](#migrations)
8. [Querying Data](#querying-data)
9. [Best Practices](#best-practices)
10. [Troubleshooting](#troubleshooting)

---

## Overview

The Neuroagent database uses **PostgreSQL** with **Prisma** as the ORM. The schema maintains compatibility with the Python backend while leveraging Prisma's type-safe query builder.

**Key Features:**
- UUID primary keys
- Cascade deletes for data integrity
- Full-text search on messages
- Token consumption tracking
- Thread-based conversation organization

**Database URL:**
```bash
DATABASE_URL="postgresql://user:password@localhost:5432/neuroagent"
```

---

## Schema Structure

### Entity Relationship Diagram

```
Thread (1) ──────< (N) Message
                        │
                        ├──< (N) ToolCall
                        ├──< (N) ToolSelection
                        ├──< (1) ComplexityEstimation
                        └──< (N) TokenConsumption
```

### File Location

The schema is defined in `prisma/schema.prisma`:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

---

## Models

### Thread

Represents a conversation thread between a user and the AI agent.

**Fields:**

| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | UUID | No | `gen_random_uuid()` | Primary key |
| `vlabId` | UUID | Yes | - | Virtual lab ID |
| `projectId` | UUID | Yes | - | Project ID |
| `title` | String | No | `"New chat"` | Thread title |
| `creationDate` | DateTime | No | `now()` | When created |
| `updateDate` | DateTime | No | Auto-updated | Last modified |
| `userId` | UUID | No | - | Owner user ID |

**Prisma Model:**
```prisma
model Thread {
  id           String    @id @map("thread_id") @db.Uuid
  vlabId       String?   @map("vlab_id") @db.Uuid
  projectId    String?   @map("project_id") @db.Uuid
  title        String    @db.VarChar
  creationDate DateTime  @map("creation_date") @db.Timestamptz(6)
  updateDate   DateTime  @map("update_date") @db.Timestamptz(6)
  userId       String    @map("user_id") @db.Uuid
  messages     Message[]

  @@map("threads")
}
```

**TypeScript Type:**
```typescript
import { Thread } from '@prisma/client';

// Thread type is auto-generated by Prisma
const thread: Thread = {
  id: '123e4567-e89b-12d3-a456-426614174000',
  vlabId: null,
  projectId: null,
  title: 'My Conversation',
  creationDate: new Date(),
  updateDate: new Date(),
  userId: '123e4567-e89b-12d3-a456-426614174001',
};
```

### Message

Represents a single message in a conversation thread.

**Fields:**
| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | UUID | No | `gen_random_uuid()` | Primary key |
| `creationDate` | DateTime | No | `now()` | When created |
| `entity` | Enum | No | - | Message source (USER, AI_MESSAGE, TOOL, AI_TOOL) |
| `content` | String | No | - | Message content (JSON) |
| `isComplete` | Boolean | No | - | Whether message is fully streamed |
| `threadId` | UUID | No | - | Parent thread ID |
| `searchVector` | tsvector | Yes | - | Full-text search vector |

**Prisma Model:**
```prisma
model Message {
  id                   String                 @id @map("message_id") @db.Uuid
  creationDate         DateTime               @map("creation_date") @db.Timestamptz(6)
  entity               entity
  content              String                 @db.VarChar
  isComplete           Boolean                @map("is_complete")
  threadId             String                 @map("thread_id") @db.Uuid
  thread               Thread                 @relation(fields: [threadId], references: [id], onDelete: Cascade)
  toolCalls            ToolCall[]
  toolSelection        ToolSelection[]
  complexityEstimation ComplexityEstimation[]
  tokenConsumption     TokenConsumption[]
  searchVector         Unsupported("tsvector")? @map("search_vector")

  @@index([searchVector], map: "ix_messages_search_vector", type: Gin)
  @@map("messages")
}
```

**Content Format:**

Messages store JSON content with different structures based on entity type:

```typescript
// USER message
{
  role: 'user',
  content: 'What is the hippocampus?'
}

// AI_MESSAGE
{
  role: 'assistant',
  content: 'The hippocampus is a brain region...',
  tool_calls: [...]  // Optional
}

// TOOL message
{
  role: 'tool',
  tool_call_id: 'call_123',
  tool_name: 'search_brain_regions',
  content: { results: [...] }
}
```

### ToolCall

Represents a tool invocation by the AI.

**Fields:**
| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | String | No | - | Tool call ID (from LLM) |
| `name` | String | No | - | Tool name |
| `arguments` | String | No | - | Tool arguments (JSON) |
| `validated` | Boolean | Yes | - | HIL validation status |
| `messageId` | UUID | No | - | Parent message ID |

**Prisma Model:**
```prisma
model ToolCall {
  id        String   @id @map("tool_call_id") @db.VarChar
  name      String   @db.VarChar
  arguments String   @db.VarChar
  validated Boolean?
  messageId String   @map("message_id") @db.Uuid
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@map("tool_calls")
}
```

### ToolSelection

Tracks which tools were selected for a message (for analytics).

**Fields:**
| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | UUID | No | `gen_random_uuid()` | Primary key |
| `toolName` | String | No | - | Selected tool name |
| `messageId` | UUID | No | - | Parent message ID |

**Prisma Model:**
```prisma
model ToolSelection {
  id        String  @id @db.Uuid
  toolName  String  @map("tool_name") @db.VarChar
  messageId String  @map("message_id") @db.Uuid
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@map("tool_selection")
}
```

### ComplexityEstimation

Stores model selection metadata for a message.

**Fields:**
| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | UUID | No | `gen_random_uuid()` | Primary key |
| `complexity` | Integer | Yes | - | Estimated complexity score |
| `model` | String | No | - | Selected model name |
| `reasoning` | Enum | Yes | - | Reasoning level |
| `messageId` | UUID | No | - | Parent message ID (unique) |

**Prisma Model:**
```prisma
model ComplexityEstimation {
  id         String           @id @db.Uuid
  complexity Int?
  model      String           @db.VarChar
  reasoning  reasoninglevels?
  messageId  String           @map("message_id") @db.Uuid
  message    Message          @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@map("complexity_estimation")
}
```

### TokenConsumption

Tracks LLM token usage for billing and analytics.

**Fields:**
| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | UUID | No | `gen_random_uuid()` | Primary key |
| `messageId` | UUID | No | - | Parent message ID |
| `type` | Enum | No | - | Token type (INPUT_CACHED, INPUT_NONCACHED, COMPLETION) |
| `task` | Enum | No | - | Task type (CHAT_COMPLETION, TOOL_SELECTION, etc.) |
| `count` | Integer | No | - | Number of tokens |
| `model` | String | No | - | Model name |

**Prisma Model:**
```prisma
model TokenConsumption {
  id        String    @id @db.Uuid
  messageId String    @map("message_id") @db.Uuid
  type      tokentype
  task      task
  count     Int
  model     String    @db.VarChar
  message   Message   @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@map("token_consumption")
}
```

---

## Relationships

### One-to-Many: Thread → Messages

A thread has many messages:

```typescript
// Get thread with all messages
const thread = await prisma.thread.findUnique({
  where: { id: threadId },
  include: { messages: true },
});

// Get messages for a thread
const messages = await prisma.message.findMany({
  where: { threadId: threadId },
  orderBy: { creationDate: 'asc' },
});
```

### One-to-Many: Message → ToolCalls

A message can have multiple tool calls:

```typescript
// Get message with tool calls
const message = await prisma.message.findUnique({
  where: { id: messageId },
  include: { toolCalls: true },
});
```

### One-to-One: Message → ComplexityEstimation

A message has at most one complexity estimation:

```typescript
// Get message with complexity estimation
const message = await prisma.message.findUnique({
  where: { id: messageId },
  include: { complexityEstimation: true },
});
```

### Cascade Deletes

Deleting a thread cascades to all related data:

```typescript
// This deletes the thread AND all its messages, tool calls, etc.
await prisma.thread.delete({
  where: { id: threadId },
});
```

---

## Enums

### entity

Message source type:

```prisma
enum entity {
  USER          // User message
  AI_TOOL       // Tool selection message
  TOOL          // Tool result message
  AI_MESSAGE    // AI response message
}
```

### task

Task type for token consumption:

```prisma
enum task {
  CHAT_COMPLETION    // Main chat completion
  TOOL_SELECTION     // Tool selection phase
  CALL_WITHIN_TOOL   // Tool execution
}
```

### tokentype

Token consumption type:

```prisma
enum tokentype {
  INPUT_NONCACHED    // Non-cached input tokens
  INPUT_CACHED       // Cached input tokens
  COMPLETION         // Output/completion tokens
}
```

### reasoninglevels

Reasoning level for model selection:

```prisma
enum reasoninglevels {
  NONE
  MINIMAL
  LOW
  MEDIUM
  HIGH
}
```

---

## Indexes

### Full-Text Search Index

Messages have a GIN index on `search_vector` for fast full-text search:

```prisma
@@index([searchVector], map: "ix_messages_search_vector", type: Gin)
```

**Usage:**
```typescript
// Search messages (requires raw SQL for tsvector)
const results = await prisma.$queryRaw`
  SELECT m.* FROM messages m
  WHERE m.search_vector @@ to_tsquery('english', ${query})
  ORDER BY ts_rank(m.search_vector, to_tsquery('english', ${query})) DESC
  LIMIT 10
`;
```

---

## Migrations

### Creating Migrations


**Development workflow:**

```bash
# 1. Edit prisma/schema.prisma
# 2. Create migration
npm run db:migrate
# Enter migration name when prompted

# 3. Migration files are created in prisma/migrations/
# 4. Migration is automatically applied to database
# 5. Prisma Client is regenerated
```

**Example: Adding a new field**

```prisma
model Thread {
  // ... existing fields
  description String? @db.VarChar  // New field
}
```

```bash
npm run db:migrate
# Name: add_thread_description
```

### Applying Migrations

**Development:**
```bash
npm run db:migrate
```

**Production:**
```bash
npm run db:migrate:deploy
```

### Migration Files

Migrations are stored in `prisma/migrations/`:

```
prisma/migrations/
├── 20240101000000_initial_schema/
│   └── migration.sql
├── 20240102000000_add_thread_description/
│   └── migration.sql
└── migration_lock.toml
```

### Rollback

Prisma doesn't have automatic rollback. To rollback:

1. **Manual approach:**
   ```bash
   # Delete the migration folder
   rm -rf prisma/migrations/20240102000000_add_thread_description

   # Reset database
   npx prisma migrate reset
   ```

2. **Create reverse migration:**
   ```sql
   -- migration.sql
   ALTER TABLE threads DROP COLUMN description;
   ```

---

## Querying Data

### Basic Queries

**Find unique:**
```typescript
const thread = await prisma.thread.findUnique({
  where: { id: threadId },
});
```

**Find many:**
```typescript
const threads = await prisma.thread.findMany({
  where: { userId: userId },
  orderBy: { updateDate: 'desc' },
  take: 10,
});
```

**Create:**
```typescript
const thread = await prisma.thread.create({
  data: {
    id: crypto.randomUUID(),
    title: 'New Chat',
    userId: userId,
    creationDate: new Date(),
    updateDate: new Date(),
  },
});
```

**Update:**
```typescript
const thread = await prisma.thread.update({
  where: { id: threadId },
  data: { title: 'Updated Title' },
});
```

**Delete:**
```typescript
await prisma.thread.delete({
  where: { id: threadId },
});
```

### Advanced Queries

**Include relations:**
```typescript
const thread = await prisma.thread.findUnique({
  where: { id: threadId },
  include: {
    messages: {
      include: {
        toolCalls: true,
        tokenConsumption: true,
      },
      orderBy: { creationDate: 'asc' },
    },
  },
});
```

**Select specific fields:**
```typescript
const threads = await prisma.thread.findMany({
  select: {
    id: true,
    title: true,
    updateDate: true,
  },
});
```

**Filtering:**
```typescript
const messages = await prisma.message.findMany({
  where: {
    threadId: threadId,
    entity: 'USER',
    creationDate: {
      gte: new Date('2024-01-01'),
    },
  },
});
```

**Pagination:**
```typescript
const threads = await prisma.thread.findMany({
  skip: (page - 1) * pageSize,
  take: pageSize,
  orderBy: { updateDate: 'desc' },
});
```

### Transactions

**Sequential operations:**
```typescript
const result = await prisma.$transaction(async (tx) => {
  // Create thread
  const thread = await tx.thread.create({
    data: { ... },
  });

  // Create first message
  const message = await tx.message.create({
    data: {
      threadId: thread.id,
      ...
    },
  });

  return { thread, message };
});
```

**Batch operations:**
```typescript
await prisma.$transaction([
  prisma.message.create({ data: message1 }),
  prisma.message.create({ data: message2 }),
  prisma.message.create({ data: message3 }),
]);
```

### Raw SQL

For complex queries:

```typescript
const results = await prisma.$queryRaw`
  SELECT t.*, COUNT(m.id) as message_count
  FROM threads t
  LEFT JOIN messages m ON m.thread_id = t.id
  WHERE t.user_id = ${userId}
  GROUP BY t.id
  ORDER BY t.update_date DESC
  LIMIT 10
`;
```

---

## Best Practices

### 1. Use Transactions for Related Operations

```typescript
// ✅ Good: Atomic operation
await prisma.$transaction(async (tx) => {
  const message = await tx.message.create({ data: messageData });
  await tx.tokenConsumption.create({
    data: {
      messageId: message.id,
      ...tokenData,
    },
  });
});

// ❌ Bad: Non-atomic, can leave partial data
const message = await prisma.message.create({ data: messageData });
await prisma.tokenConsumption.create({
  data: { messageId: message.id, ...tokenData },
});
```

### 2. Use Select to Reduce Data Transfer

```typescript
// ✅ Good: Only fetch needed fields
const threads = await prisma.thread.findMany({
  select: { id: true, title: true },
});

// ❌ Bad: Fetches all fields
const threads = await prisma.thread.findMany();
```

### 3. Use Include Wisely

```typescript
// ✅ Good: Include only what you need
const thread = await prisma.thread.findUnique({
  where: { id },
  include: {
    messages: {
      take: 50,  // Limit messages
      orderBy: { creationDate: 'desc' },
    },
  },
});

// ❌ Bad: Loads all messages (could be thousands)
const thread = await prisma.thread.findUnique({
  where: { id },
  include: { messages: true },
});
```

### 4. Handle Unique Constraint Violations

```typescript
try {
  await prisma.thread.create({ data: threadData });
} catch (error) {
  if (error.code === 'P2002') {
    // Unique constraint violation
    throw new Error('Thread with this ID already exists');
  }
  throw error;
}
```

### 5. Use Proper Date Handling

```typescript
// ✅ Good: Use Date objects
const thread = await prisma.thread.create({
  data: {
    creationDate: new Date(),
    updateDate: new Date(),
  },
});

// ❌ Bad: Don't use strings
const thread = await prisma.thread.create({
  data: {
    creationDate: '2024-01-01',  // Wrong!
  },
});
```

### 6. Clean Up Test Data

```typescript
// In tests, clean up after each test
afterEach(async () => {
  await prisma.message.deleteMany();
  await prisma.thread.deleteMany();
});
```

---

## Troubleshooting

### Prisma Client Out of Sync

**Problem:** TypeScript errors about missing fields or methods.

**Solution:**
```bash
npm run db:generate
```

### Migration Conflicts

**Problem:** Migration fails due to conflicts.

**Solution:**
```bash
# Reset database (WARNING: deletes all data)
npx prisma migrate reset

# Or resolve manually
npx prisma migrate resolve --applied <migration_name>
```

### Connection Errors

**Problem:** Cannot connect to database.

**Solution:**
1. Check `DATABASE_URL` in `.env`
2. Verify PostgreSQL is running
3. Test connection:
   ```bash
   psql $DATABASE_URL
   ```

### Slow Queries

**Problem:** Queries are slow.

**Solution:**
1. Add indexes:
   ```prisma
   @@index([userId])
   @@index([creationDate])
   ```

2. Use `select` to reduce data:
   ```typescript
   select: { id: true, title: true }
   ```

3. Enable query logging:
   ```typescript
   const prisma = new PrismaClient({
     log: ['query', 'info', 'warn', 'error'],
   });
   ```

### Type Errors

**Problem:** TypeScript complains about Prisma types.

**Solution:**
```bash
# Regenerate types
npm run db:generate

# Restart TypeScript server in VS Code
# Cmd+Shift+P -> "TypeScript: Restart TS Server"
```

---

## Additional Resources

- [Prisma Schema Reference](../prisma/schema.prisma)
- [Prisma Documentation](https://www.prisma.io/docs)
- [Migration Guide](../prisma/MIGRATION_GUIDE.md)
- [Migration Workflow](../prisma/MIGRATION_WORKFLOW.md)
- [Database Client](../src/lib/db/client.ts)

---

## Schema Visualization

```
┌─────────────────────────────────────────────────────────────┐
│                          Thread                              │
├─────────────────────────────────────────────────────────────┤
│ id: UUID (PK)                                               │
│ vlabId: UUID?                                               │
│ projectId: UUID?                                            │
│ title: String                                               │
│ creationDate: DateTime                                      │
│ updateDate: DateTime                                        │
│ userId: UUID                                                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     │ 1:N
                     │
┌────────────────────▼────────────────────────────────────────┐
│                         Message                              │
├─────────────────────────────────────────────────────────────┤
│ id: UUID (PK)                                               │
│ creationDate: DateTime                                      │
│ entity: Enum                                                │
│ content: String (JSON)                                      │
│ isComplete: Boolean                                         │
│ threadId: UUID (FK)                                         │
│ searchVector: tsvector                                      │
└──┬──────────┬──────────┬──────────┬───────────────────────┘
   │          │          │          │
   │ 1:N      │ 1:N      │ 1:1      │ 1:N
   │          │          │          │
   ▼          ▼          ▼          ▼
ToolCall  ToolSelection  Complexity  TokenConsumption
                         Estimation
```
