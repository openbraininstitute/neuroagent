/**
 * OBI-One circuit connectivity metrics tool.
 * Translated from: backend/src/neuroagent/tools/obione_circuitconnectivitymetrics_getone.py
 */

import { z } from 'zod';
import { HTTPError } from 'ky';
import { BaseTool } from '../base-tool';
import { ObiOneContextVariables } from './types';
import {
  zConnectivityMetricsRequest,
  zConnectivityMetricsOutput,
} from '../autogenerated_types/obione/zod.gen';

/**
 * Input schema for the circuit connectivity metrics tool.
 * Extends the autogenerated zConnectivityMetricsRequest schema with additional field descriptions.
 */
const CircuitConnectivityMetricsGetOneInputSchema = zConnectivityMetricsRequest.extend({
  circuit_id: z
    .string()
    .uuid()
    .describe(
      'ID of the circuit from which the connectivity metrics should be computed.'
    ),
  pre_selection: z
    .record(z.union([z.string(), z.array(z.string())]))
    .nullable()
    .optional()
    .describe(
      'Additional filter for pre-synaptic neurons in Sonata nodeset JSON format. ' +
        'Applied on top of pre_node_set if present. ' +
        'Format: {"property": "value"} or {"property": ["val1", "val2"]}. ' +
        'Example: {"mtype": "L2/3PC"} filters to L2/3 pyramidal cells. ' +
        'Note: Inspect the `property_unique_values` of the corresponding node population in the `obione-circuitmetrics-getone` tool output to see valid values. ' +
        'IMPORTANT: All property values must be provided as strings, never as integers or other data types. ' +
        "For layer filtering, use string integers like '2', '3', '4', '5', '6' instead of numeric values. " +
        'If not provided, only pre_node_set filter is applied.'
    ),
  post_selection: z
    .record(z.union([z.string(), z.array(z.string())]))
    .nullable()
    .optional()
    .describe(
      'Additional filter for post-synaptic neurons in Sonata nodeset JSON format. ' +
        'Applied on top of post_node_set if present. ' +
        'Format: {"property": "value"} or {"property": ["val1", "val2"]}. ' +
        'Example: {"mtype": "L5PC"} filters to L5 pyramidal cells. ' +
        'Note: Inspect the `property_unique_values` of the corresponding node population in the `obione-circuitmetrics-getone` tool output to see valid values. ' +
        'IMPORTANT: All property values must be provided as strings, never as integers or other data types. ' +
        "For layer filtering, use string integers like '2', '3', '4', '5', '6' instead of numeric values. " +
        'If not provided, only post_node_set filter is applied.'
    ),
});

/**
 * Tool to compute the circuit connectivity metrics.
 */
export class CircuitConnectivityMetricsGetOneTool extends BaseTool<
  typeof CircuitConnectivityMetricsGetOneInputSchema,
  ObiOneContextVariables
> {
  static toolName = 'obione-circuitconnectivitymetrics-getone';
  static toolDescription =
    'Analyze connectivity patterns between neuron groups in a circuit.\n\n' +
    '**Use this tool to:**\n' +
    '- Get connection probabilities between pre/post synaptic groups\n' +
    '- Calculate mean synapse counts per connection\n' +
    '- Group results by properties (mtype, layer, etc.)\n\n' +
    '**Prerequisites:** Call `obione-circuitmetrics-getone` first to get available edge populations, node sets, property names and possible property values.\n\n' +
    '**Neuron filtering (optional):**\n' +
    '**IMPORTANT:** All property values in pre_selection and post_selection must be provided as strings (e.g., `{"layer": "2"}` not `{"layer": 2}`).\n\n' +
    "- `pre_node_set`/`post_node_set`: 'Excitatory', 'Inhibitory', or custom selections\n" +
    '- `pre_selection`: Additional filter for pre-synaptic neurons (applied on top of pre_node_set)\n' +
    '- `post_selection`: Additional filter for post-synaptic neurons (applied on top of post_node_set)\n' +
    '- Format: `{"property": "value"}` or `{"property": ["val1", "val2"]}`\n' +
    '- Example: `{"mtype": "L2/3PC"}` filters to L2/3 pyramidal cells\n\n' +
    '**Common parameters:**\n' +
    "- `edge_population`: e.g., 'S1nonbarrel_neurons__S1nonbarrel_neurons__chemical'\n" +
    "- `group_by`: 'mtype', 'layer', 'synapse_class', etc.\n\n" +
    '**Example:** Analyze L2/3 pyramidal cells â†’ L5 pyramidal cells connections grouped by morphological type.';

  static toolNameFrontend = 'Compute Circuit Connectivity Metrics';
  static toolDescriptionFrontend =
    'Analyze connectivity patterns between neuron groups.\n\n' +
    'Returns connection probabilities and mean synapse counts between pre/post synaptic groups, grouped by specified criteria (e.g., mtype, layer).\n\n' +
    'Supports optional pre_selection and post_selection parameters as additional filters on top of node sets.';

  static utterances = [
    'Analyze the circuit connectivity',
    'Compute connectivity metrics for this circuit',
    'Get connectivity information about this circuit',
    'Analyze synaptic connections in this circuit',
  ];

  override contextVariables: ObiOneContextVariables;
  override inputSchema = CircuitConnectivityMetricsGetOneInputSchema;

  constructor(contextVariables: ObiOneContextVariables) {
    super();
    this.contextVariables = contextVariables;
  }

  /**
   * Run the circuit connectivity metrics calculations.
   */
  async execute(
    input: z.infer<typeof CircuitConnectivityMetricsGetOneInputSchema>
  ): Promise<z.infer<typeof zConnectivityMetricsOutput>> {
    const { obiOneUrl, vlabId, projectId, httpClient } = this.contextVariables;

    // Prepare headers
    const headers: Record<string, string> = {};
    if (vlabId) {
      headers['virtual_lab_id'] = vlabId;
    }
    if (projectId) {
      headers['project_id'] = projectId;
    }

    // Prepare request body (exclude undefined/default values)
    const requestBody: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(input)) {
      if (value !== undefined) {
        requestBody[key] = value;
      }
    }

    try {
      const response = await httpClient
        .post(`${obiOneUrl}/declared/connectivity-metrics`, {
          headers,
          json: requestBody,
        })
        .json();

      // Validate response with Zod schema
      return zConnectivityMetricsOutput.parse(response);
    } catch (error) {
      if (error instanceof HTTPError) {
        const { status, statusText } = error.response;
        let responseBody = '';
        try {
          responseBody = await error.response.text();
        } catch {
          // Ignore if we can't read the body
        }
        throw new Error(
          `The connectivity metrics endpoint returned a non 200 response code. Error: ${status} ${statusText}${responseBody ? ': ' + responseBody : ''}`
        );
      }
      throw error;
    }
  }

  /**
   * Check if the tool is online.
   */
  static async isOnline(contextVariables: ObiOneContextVariables): Promise<boolean> {
    try {
      const { obiOneUrl, httpClient } = contextVariables;
      const healthUrl = `${obiOneUrl.replace(/\/$/, '')}/health`;

      await httpClient.get(healthUrl);
      return true;
    } catch {
      return false;
    }
  }
}
