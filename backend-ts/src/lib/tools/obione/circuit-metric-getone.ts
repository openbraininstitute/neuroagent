/**
 * OBI-One circuit metrics tool.
 * Translated from: backend/src/neuroagent/tools/obione_circuitmetrics_getone.py
 */

import { z } from 'zod';
import { HTTPError } from 'ky';
import { BaseTool } from '../base-tool';
import { ObiOneContextVariables } from './types';
import {
  zCircuitMetricsEndpointDeclaredCircuitMetricsCircuitIdGetData,
  zCircuitMetricsOutput,
} from '../autogenerated_types/obione/zod.gen';

/**
 * Input schema for the circuit metrics tool.
 * Extends the autogenerated schema with overridden field descriptions and constraints.
 */
const CircuitMetricGetOneInputSchema =
  zCircuitMetricsEndpointDeclaredCircuitMetricsCircuitIdGetData.shape.path
    .extend({
      circuit_id: z
        .string()
        .uuid()
        .describe('ID of the circuit from which the metrics should be computed.'),
    })
    .merge(
      zCircuitMetricsEndpointDeclaredCircuitMetricsCircuitIdGetData.shape.query
        .unwrap()
        .extend({
          // Override the query params with proper constraints and make them optional with defaults
          level_of_detail_nodes: z
            .number()
            .int()
            .gte(0)
            .lte(3)
            .default(1)
            .optional()
            .describe('Level of detail for nodes in the response.'),
          level_of_detail_edges: z
            .number()
            .int()
            .gte(0)
            .lte(3)
            .default(1)
            .optional()
            .describe('Level of detail for edges in the response.'),
        })
    );

/**
 * Tool to compute the circuit metrics.
 */
export class CircuitMetricGetOneTool extends BaseTool<
  typeof CircuitMetricGetOneInputSchema,
  ObiOneContextVariables
> {
  static toolName = 'obione-circuitmetrics-getone';
  static toolDescription =
    'Given a circuit ID, compute the features of it. ' +
    'This tool returns comprehensive circuit metadata including node populations, edge populations, and available filterable properties.\n\n' +
    '## What This Tool Provides\n' +
    '- **Circuit structure**: Node populations, edge populations, and their properties\n' +
    '- **Filterable properties**: Available columns and values for connectivity analysis\n' +
    '- **Node sets**: Predefined groups for connectivity filtering\n' +
    '- **Population statistics**: Counts and property distributions\n\n' +
    '## What This Tool Does NOT Provide\n' +
    '- **Connection probabilities**: Use `obione-circuitconnectivitymetrics-getone` instead\n' +
    '- **Synapse counts**: Use `obione-circuitconnectivitymetrics-getone` instead\n' +
    '- **Connectivity patterns**: Use `obione-circuitconnectivitymetrics-getone` instead\n' +
    '- **Functional analysis**: Use `obione-circuitconnectivitymetrics-getone` instead\n\n' +
    '## Top-Level Output Fields\n\n' +
    '### Node Populations\n' +
    "- **biophysical_node_populations**: Contains biophysical neuron populations with detailed properties including:\n" +
    "  - `property_names`: List of available column names for filtering (e.g., 'layer', 'mtype', 'synapse_class')\n" +
    '  - `property_unique_values`: For categorical columns, shows all unique values available for filtering\n' +
    '  - `property_value_counts`: Count of occurrences for each unique value\n' +
    '- **virtual_node_populations**: Contains virtual/artificial neuron populations with similar property structure\n' +
    '- **names_of_nodesets**: Predefined node sets that can be referenced in connectivity analysis\n\n' +
    '### Edge Populations\n' +
    '- **chemical_edge_populations**: Chemical synaptic connections between populations with properties like:\n' +
    '  - Synaptic properties (conductance, delay, decay_time, etc.)\n' +
    '  - Spatial properties (afferent/efferent coordinates, section info)\n' +
    '  - Connection statistics and degree metrics\n' +
    '- **electrical_edge_populations**: Electrical gap junction connections (if present)\n\n' +
    '### Usage for Connectivity Analysis\n' +
    'The `property_names` and `property_unique_values` from node populations are essential for:\n' +
    '- Building `pre_selection` and `post_selection` filters in connectivity metrics tools\n' +
    '- Understanding available categorical values for filtering (e.g., layer values, mtype values)\n' +
    '- Identifying which properties can be used for grouping and analysis\n\n' +
    'Example: Use `level_of_detail_nodes=1` to get detailed property information for filtering in connectivity analysis.';

  static toolNameFrontend = 'Compute Circuit Metrics';
  static toolDescriptionFrontend =
    'Analyze a circuit, and get more insights into its properties.';

  static utterances = [
    'Analyze the circuit features',
    'Compute metrics for this circuit',
    'Get some more information about this circuit',
  ];

  override contextVariables: ObiOneContextVariables;
  override inputSchema = CircuitMetricGetOneInputSchema;

  constructor(contextVariables: ObiOneContextVariables) {
    super();
    this.contextVariables = contextVariables;
  }

  /**
   * Run the circuit metrics calculations.
   */
  async execute(
    input: z.infer<typeof CircuitMetricGetOneInputSchema>
  ): Promise<z.infer<typeof zCircuitMetricsOutput>> {
    const { obiOneUrl, vlabId, projectId, httpClient } = this.contextVariables;

    // Prepare headers
    const headers: Record<string, string> = {};
    if (vlabId) {
      headers['virtual_lab_id'] = vlabId;
    }
    if (projectId) {
      headers['project_id'] = projectId;
    }

    // Prepare query params (exclude circuit_id which goes in the path)
    // Note: We use URLSearchParams to properly handle parameters
    const searchParams = new URLSearchParams();
    if (input['level_of_detail_nodes'] !== undefined) {
      searchParams.append('level_of_detail_nodes', String(input['level_of_detail_nodes']));
    }
    if (input['level_of_detail_edges'] !== undefined) {
      searchParams.append('level_of_detail_edges', String(input['level_of_detail_edges']));
    }

    try {
      const response = await httpClient
        .get(`${obiOneUrl}/declared/circuit-metrics/${input.circuit_id}`, {
          headers,
          searchParams,
        })
        .json();

      // Validate response with Zod schema
      return zCircuitMetricsOutput.parse(response);
    } catch (error) {
      if (error instanceof HTTPError) {
        const { status, statusText } = error.response;
        let responseBody = '';
        try {
          responseBody = await error.response.text();
        } catch {
          // Ignore if we can't read the body
        }
        throw new Error(
          `The circuit metrics endpoint returned a non 200 response code. Error: ${status} ${statusText}${responseBody ? ': ' + responseBody : ''}`
        );
      }
      throw error;
    }
  }

  /**
   * Check if the tool is online.
   */
  static async isOnline(contextVariables: ObiOneContextVariables): Promise<boolean> {
    try {
      const { obiOneUrl, httpClient } = contextVariables;
      const healthUrl = `${obiOneUrl.replace(/\/$/, '')}/health`;

      await httpClient.get(healthUrl);
      return true;
    } catch {
      return false;
    }
  }
}
