/**
 * OBI-One Generate Simulations Config tool.
 * Translated from: backend/src/neuroagent/tools/obione_generatesimulationsconfig.py
 *
 * Uses Vercel AI SDK with a schema transformer that converts .optional() to .nullable()
 * for strict mode compatibility. This matches Python's behavior where beta.chat.completions.parse()
 * automatically normalizes schemas.
 */

import { z } from 'zod';
import { generateText, Output, NoObjectGeneratedError } from 'ai';
import { createOpenAI } from '@ai-sdk/openai';
import { type KyInstance } from 'ky';
import { BaseTool, type BaseContextVariables } from '../base-tool';
import {
  zCircuitSimulationScanConfig,
  zObiOneScientificTasksGenerateSimulationConfigsCircuitSimulationScanConfigInitialize,
} from '../autogenerated_types/obione/zod.gen';
import type { SharedState } from '@/types';

/**
 * Recursively transform a Zod schema to make it compatible with OpenAI strict mode.
 * This involves:
 * 1. Converting .optional() to .nullable() - fields must be present but can be null
 * 2. Flattening .and() (ZodIntersection) which creates allOf (not supported in strict mode)
 */
function makeOptionalFieldsNullable(schema: z.ZodTypeAny): z.ZodTypeAny {
  // Handle ZodOptional - convert to nullable (field must be present, can be null)
  if (schema instanceof z.ZodOptional) {
    const unwrapped = schema.unwrap();
    const transformed = makeOptionalFieldsNullable(unwrapped);
    return transformed.nullable();
  }

  // Handle ZodNullable - keep as is but recursively transform inner
  if (schema instanceof z.ZodNullable) {
    const unwrapped = (schema as any)._def.innerType;
    const transformed = makeOptionalFieldsNullable(unwrapped);
    return transformed.nullable();
  }

  // Handle ZodDefault - keep the default as-is, but transform the inner schema
  if (schema instanceof z.ZodDefault) {
    const innerSchema = (schema as any)._def.innerType;
    const defaultValue = (schema as any)._def.defaultValue();
    const transformed = makeOptionalFieldsNullable(innerSchema);
    return transformed.default(defaultValue);
  }

  // Handle ZodIntersection (.and()) - FLATTEN to avoid allOf
  if (schema instanceof z.ZodIntersection) {
    const left = (schema as any)._def.left;
    const right = (schema as any)._def.right;

    const transformedLeft = makeOptionalFieldsNullable(left);
    const transformedRight = makeOptionalFieldsNullable(right);

    if (transformedLeft instanceof z.ZodObject && transformedRight instanceof z.ZodObject) {
      const leftShape = transformedLeft.shape;
      const rightShape = transformedRight.shape;
      const mergedShape = { ...leftShape, ...rightShape };
      return z.object(mergedShape);
    }

    return transformedRight;
  }

  // Handle ZodObject - recursively transform all fields
  if (schema instanceof z.ZodObject) {
    const shape = schema.shape;
    const newShape: Record<string, z.ZodTypeAny> = {};

    for (const [key, value] of Object.entries(shape)) {
      newShape[key] = makeOptionalFieldsNullable(value as z.ZodTypeAny);
    }

    return z.object(newShape);
  }

  // Handle ZodUnion - recursively transform all options
  if (schema instanceof z.ZodUnion) {
    const options = (schema as any)._def.options;
    return z.union(options.map((opt: z.ZodTypeAny) => makeOptionalFieldsNullable(opt)));
  }

  // Handle ZodRecord - transform the value schema
  if (schema instanceof z.ZodRecord) {
    const valueSchema = (schema as any)._def.valueType;
    return z.record(makeOptionalFieldsNullable(valueSchema));
  }

  // Handle ZodArray - transform the element schema
  if (schema instanceof z.ZodArray) {
    const elementSchema = (schema as any)._def.type;
    return z.array(makeOptionalFieldsNullable(elementSchema));
  }

  return schema;
}

/**
 * Input schema for the generate simulations config tool.
 */
const GenerateSimulationsConfigInputSchema = z.object({
  circuit_id: z
    .string()
    .uuid()
    .describe('UUID of the target circuit that has to be simulated.'),
  config_request: z
    .string()
    .describe(
      "A detailed description of the desired simulation configuration that will be processed by an LLM to generate JSON. This should contain either: (1) a complete specification for a new configuration including all required parameters and settings, or (2) specific modifications to be applied to an existing configuration (e.g., 'change simulation length to 5000ms', 'Apply an extra stimulus for excitatory neurons', 'record only inhibitory neurons instead'). Be explicit about which approach you're using and provide clear, actionable details."
    ),
});

/**
 * Context variables for the generate simulations config tool.
 */
export interface GenerateSimulationsConfigContextVariables extends BaseContextVariables {
  /** HTTP client (ky instance) pre-configured with JWT token */
  httpClient: KyInstance;

  /** OBI-One API base URL */
  obiOneUrl: string;

  /** Virtual lab ID (optional) */
  vlabId?: string;

  /** Project ID (optional) */
  projectId?: string;

  /** Shared state containing existing configuration */
  sharedState?: SharedState | null;

  /** Entity frontend URL */
  entityFrontendUrl: string;

  /** Model to use for generation (optional, defaults to gpt-4o-mini) */
  model?: string;

  /** OpenAI API key for Vercel AI SDK */
  openaiApiKey?: string;

  /** Token consumption tracking (optional) */
  tokenConsumption?: {
    model: string;
    input_tokens: number;
    output_tokens: number;
    total_tokens: number;
  } | null;
}

/**
 * Helper function to extract model structure (simplified version)
 */
function extractModelStructure(_schema: z.ZodType): Record<string, any> {
  // Simplified - in production, this would recursively extract the schema structure
  return { note: 'Schema structure available in Zod schema' };
}

/**
 * Modified Initialize schema without circuit reference.
 * Matches Python's InitializeNoCircuit class using SkipJsonSchema.
 */
const InitializeNoCircuitSchema =
  zObiOneScientificTasksGenerateSimulationConfigsCircuitSimulationScanConfigInitialize.omit({
    circuit: true,
  });

/**
 * Base schema with transformation to handle strict mode
 */
const CircuitSimulationScanConfigModifiedSchema = makeOptionalFieldsNullable(
  zCircuitSimulationScanConfig.extend({
    initialize: InitializeNoCircuitSchema,
  })
) as z.ZodType<any>;

// Debug: Log the schema structure to verify transformation
if (process.env.NODE_ENV === 'development') {
  try {
    const schemaShape = (CircuitSimulationScanConfigModifiedSchema as any).shape;
    if (schemaShape) {
      console.log('[Schema Debug] stimuli type:', schemaShape.stimuli?.constructor?.name);
      console.log('[Schema Debug] recordings type:', schemaShape.recordings?.constructor?.name);
    }
  } catch (e) {
    // Ignore debug errors
  }
}

/**
 * Helper function to filter out null values from the response
 */
function filterNulls(obj: any): any {
  if (obj === null || obj === undefined) return undefined;
  if (Array.isArray(obj)) return obj.map(filterNulls).filter(v => v !== undefined && v !== null);
  if (typeof obj === 'object') {
    const filtered: Record<string, any> = {};
    for (const [key, value] of Object.entries(obj)) {
      const filteredValue = filterNulls(value);
      if (filteredValue !== undefined && filteredValue !== null) {
        filtered[key] = filteredValue;
      }
    }
    return filtered;
  }
  return obj;
}

/**
 * Tool to generate simulation configurations using LLM.
 */
export class GenerateSimulationsConfigTool extends BaseTool<
  typeof GenerateSimulationsConfigInputSchema,
  GenerateSimulationsConfigContextVariables
> {
  static toolName = 'obione-generatesimulationsconfig';
  static toolDescription =
    'This tool generates JSON configurations for simulations based on natural language descriptions. ' +
    'It accepts both complete configuration specifications and modification requests for existing configurations, ' +
    'using an LLM with structured output to produce the corresponding JSON.\n' +
    'Always use a circuit ID with this tool. If you can\'t see a reference to an existing circuit in the chat, ask for clarifications.\n\n' +
    'For modifications, you can provide incremental change descriptions - the tool will interpret these in the context of the existing configuration. ' +
    'You don\'t need to describe the entire final state; focused modification requests are fully supported.\n\n' +
    'Input: Either a comprehensive new configuration description OR specific modifications to an existing configuration\n' +
    'IMPORTANT: In the config_request parameter, only describe what the user explicitly requested. ' +
    'Do NOT include default values or standard parameters - the downstream LLM will handle those automatically. ' +
    'The output will always be valid JSON.\n' +
    'The downstream LLM uses structured output. It has a lot of information about the structure and defaults of the simulations form.\n\n' +
    `Available configuration fields: ${JSON.stringify(extractModelStructure(zCircuitSimulationScanConfig))}\n\n` +
    'Output: Valid simulation config json\n\n' +
    'Use this tool when users need to:\n' +
    '- Create new configurations from scratch\n' +
    '- Modify, update, or tweak existing configurations\n' +
    '- Convert configuration requirements into structured JSON format\n\n' +
    'Always call this tool to generate a simulation config, never attempt to generate one yourself.\n' +
    'Do not try to generate a simulation config yourself if the tool fails.\n\n' +
    'CRITICAL: DO NOT WRITE THE FINAL JSON OUTPUT IN THE CHAT. It will be automatically taken care of by the platform.';

  static toolNameFrontend = 'Generate Simulation Config';
  static toolDescriptionFrontend =
    'Create or modify JSON configurations using natural language.\n' +
    'Simply specify in plain english what you want your configuration to achieve or what changes you\'d like to make.';

  static utterances = [
    'Create a simulation configuration',
    'Generate a config for me',
    'Set up simulation parameters',
  ];

  override contextVariables: GenerateSimulationsConfigContextVariables;
  override inputSchema = GenerateSimulationsConfigInputSchema;

  constructor(contextVariables: GenerateSimulationsConfigContextVariables) {
    super();
    this.contextVariables = contextVariables;
  }

  /**
   * Run the tool to generate simulation configuration.
   */
  async execute(
    input: z.infer<typeof GenerateSimulationsConfigInputSchema>
  ): Promise<z.infer<typeof zCircuitSimulationScanConfig>> {
    const {
      httpClient,
      obiOneUrl,
      vlabId,
      projectId,
      sharedState,
      entityFrontendUrl,
      model = 'gpt-5-mini',
      openaiApiKey,
    } = this.contextVariables;

    // Validate OpenAI API key is provided
    if (!openaiApiKey) {
      throw new Error(
        'OpenAI API key is required for this tool. Please configure OPENAI_API_KEY or LLM__OPENAI_TOKEN environment variable.'
      );
    }

    // Get the available nodesets in the circuit
    const headers: Record<string, string> = {};
    if (vlabId) {
      headers['virtual-lab-id'] = vlabId;
    }
    if (projectId) {
      headers['project-id'] = projectId;
    }

    try {
      const circuitNodeSetResponse = await httpClient
        .get(
          `${obiOneUrl.replace(/\/$/, '')}/declared/circuit/${input.circuit_id}/nodesets`,
          { headers }
        )
        .json();

      // Check for existing state passed by frontend
      if (!sharedState) {
        throw new Error(
          'A state with key `smc_simulation_config` must be provided in the request body to trigger this tool.'
        );
      }

      const baseSimulationForm = sharedState.smc_simulation_config;
      if (baseSimulationForm === null || baseSimulationForm === undefined) {
        throw new Error(
          `To edit a Small Microcircuit Simulation, first navigate to ${entityFrontendUrl}/simulate?&s=new&t=small-microcircuit, pick a circuit, click 'New Simulation' and call the tool again.`
        );
      }

      // Debug: Check the structure of the input
      console.log('[GenerateSimulationsConfig] Input structure check:');
      console.log('  stimuli type:', Array.isArray(baseSimulationForm['stimuli']) ? 'ARRAY' : typeof baseSimulationForm['stimuli']);
      console.log('  recordings type:', Array.isArray(baseSimulationForm['recordings']) ? 'ARRAY' : typeof baseSimulationForm['recordings']);
      console.log('  neuron_sets type:', Array.isArray(baseSimulationForm['neuron_sets']) ? 'ARRAY' : typeof baseSimulationForm['neuron_sets']);

      // Build system prompt with circuit nodesets
      const systemPrompt = `# Simulation Configuration Generator

You are an expert at generating valid JSON simulation configurations following the CircuitSimulationScanConfig schema.
You will receive two inputs:
1. A description of the required configuration changes or specifications
2. The current simulation configuration JSON (either a default/empty config or an existing one)

## Task Approach
You are always modifying the provided configuration. The nature of modifications depends on the starting point:
- **Starting from default config**: User requests typically describe complete simulation requirements ("Generate a simulation with X neurons for Y duration")
- **Starting from existing config**: User requests typically describe incremental changes ("Add stimulus X", "Set parameter Y to Z")

Apply the requested changes to the provided configuration, replacing or adding elements as needed.

## Timestamps and Stimuli Logic
- **Only generate timestamps if stimuli will use them**
- Choose stimulus type based on timing pattern:
  - **Single timestamp + MultiPulse**: For repeated pulses at one timepoint
  - **Multiple timestamps + single-pulse stimulus**: For stimuli at different timepoints
  - **Never combine MultiPulse with repetitive timestamps**
- Modify existing timing logic only when specifically requested

## Parameter Values
- Use single values, not single-element lists (e.g., \`"duration": 500.0\` not \`"duration": [500.0]\`)
- Lists indicate parameter sweeps - only use when scanning multiple values
- For IDNeuronSet, include meaningful number of neurons (typically 50+ for populations)
- Update only the parameters mentioned in the modification request

## Modification Guidelines
- **Comprehensive requests** (from default configs): Build out the full simulation as described, replacing default values
- **Incremental requests** (from existing configs): Make targeted changes while preserving unmodified elements
- "Add X" means include X alongside existing elements (unless it conflicts)
- "Remove" or "delete" means eliminate the specified element entirely
- "Set" or "change" means replace the specified parameter with the new value
- When building from defaults, interpret requests as comprehensive specifications rather than additions

## Neuron Sets and References
- Generate neuron sets in the "neuron_sets" dictionary with meaningful keys
- **Only create neuron sets that will actually be used**
- For references (NeuronSetReference, TimestampsReference):
  - \`block_name\`: the dictionary key (e.g., "all_neurons")
  - \`block_dict_name\`: the parent dictionary name (e.g., "neuron_sets", "timestamps")
- Avoid duplicate or unused neuron sets unless specifically requested
- Whenever you see a \`circuit_property_type = CircuitNodeSet\` in the schema of the neuron_sets you want to use, the string value within \`node_set\` must be one of the following: ${JSON.stringify(circuitNodeSetResponse)}

## Validation Checklist
Before outputting, verify:
- [ ] All references use existing dictionary keys with correct block_dict_name
- [ ] No unused neuron sets or timestamps
- [ ] Stimulus timing logic is coherent
- [ ] No single-element lists unless intentional parameter sweep
- [ ] Requested changes are accurately applied to the provided configuration
- [ ] Configuration structure remains valid and consistent

Generate only the JSON configuration, ensuring all references are internally consistent.`;

      const userMessage = `
CURRENT SIMULATION CONFIG JSON:
${JSON.stringify(baseSimulationForm)}

REQUIREMENTS:
${input.config_request}
`;

      // Use Vercel AI SDK with base schema (no transformation)
      // Temporarily disable strict mode to test if basic functionality works
      const openaiClient = createOpenAI({
        apiKey: openaiApiKey,
      });

      console.log('[GenerateSimulationsConfig] Using generateText with Output.object (strict mode enabled by default)');

      // Debug: Check the structure of the input
      try {
        const schemaShape = (CircuitSimulationScanConfigModifiedSchema as any).shape;
        if (schemaShape) {
          console.log('[Schema Debug] stimuli field type:', schemaShape.stimuli?.constructor?.name);
          console.log('[Schema Debug] recordings field type:', schemaShape.recordings?.constructor?.name);
        }
      } catch (e) {
        console.error('[Schema Debug] Error inspecting schema:', e);
      }

      try {
        const result = await generateText({
          model: openaiClient(model),
          experimental_output: Output.object({
            schema: CircuitSimulationScanConfigModifiedSchema,
          }),
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userMessage },
          ],
          experimental_providerMetadata: {
            openai: {
              structuredOutputs: true,
              reasoningEffort: 'low',
            },
          },
        });

        console.log('[GenerateSimulationsConfig] Generation successful');

        const validatedConfig = result.experimental_output as any;

        // Add the circuit reference back
        // Match Python's behavior: use empty objects for null/undefined fields
        const outputConfig: z.infer<typeof zCircuitSimulationScanConfig> = {
          type: 'CircuitSimulationScanConfig',
          timestamps: validatedConfig.timestamps || {},
          stimuli: validatedConfig.stimuli || {},
          recordings: validatedConfig.recordings || {},
          neuron_sets: validatedConfig.neuron_sets || {},
          synaptic_manipulations: validatedConfig.synaptic_manipulations || {},
          initialize: {
            ...validatedConfig.initialize,
            type: 'CircuitSimulationScanConfig.Initialize',
            circuit: {
              type: 'CircuitFromID',
              id_str: input.circuit_id,
            },
          },
          info: validatedConfig.info,
        };

        // Track token consumption if available
        if (result.usage && this.contextVariables.tokenConsumption !== undefined) {
          this.contextVariables.tokenConsumption = {
            model,
            input_tokens: result.usage.promptTokens || 0,
            output_tokens: result.usage.completionTokens || 0,
            total_tokens: result.usage.totalTokens || 0,
          };
        }

        // Normalize numbers for TypeScript JSON compatibility
        return outputConfig;
      } catch (generationError) {
        // Enhanced error logging
        if (NoObjectGeneratedError.isInstance(generationError)) {
          console.error('[GenerateSimulationsConfig] NoObjectGeneratedError details:');
          console.error('  Cause:', generationError.cause);
          console.error('  Text:', generationError.text);
          console.error('  Response:', JSON.stringify(generationError.response, null, 2));
          console.error('  Usage:', generationError.usage);
        } else {
          console.error('[GenerateSimulationsConfig] Generation error:', {
            errorType: generationError?.constructor?.name,
            errorMessage: generationError instanceof Error ? generationError.message : String(generationError),
            errorCause: (generationError as any)?.cause,
          });
        }

        throw generationError;
      }
    } catch (error) {
      // Log detailed error information
      console.error('[GenerateSimulationsConfig] Error details:', {
        errorType: error?.constructor?.name,
        errorMessage: error instanceof Error ? error.message : String(error),
        errorStack: error instanceof Error ? error.stack : undefined,
      });

      if (error instanceof Error) {
        throw new Error(`Failed to generate simulation config: ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Check if the tool is online.
   */
  static async isOnline(): Promise<boolean> {
    // This tool is always online as it only depends on OpenAI
    return true;
  }
}
