// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * AgePeriod
 */
export const zAgePeriod = z.enum([
    'prenatal',
    'postnatal',
    'unknown'
]);

/**
 * All Neurons
 *
 * All biophysical neurons.
 */
export const zAllNeurons = z.object({
    type: z.literal('AllNeurons').optional().default('AllNeurons'),
    sample_percentage: z.union([
        z.number().gte(0).lte(100),
        z.array(z.number().gte(0).lte(100)).min(1)
    ]).optional().default(100),
    sample_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * AmplitudeInput
 *
 * Amplitude class.
 */
export const zAmplitudeInput = z.object({
    min_value: z.union([
        z.number(),
        z.null()
    ]).optional(),
    max_value: z.union([
        z.number(),
        z.null()
    ]).optional()
});

/**
 * Assets
 */
export const zAssets = z.object({
    type: z.literal('Assets').optional().default('Assets'),
    swc_file: z.union([
        z.string(),
        z.null()
    ]).optional(),
    asc_file: z.union([
        z.string(),
        z.null()
    ]).optional(),
    h5_file: z.union([
        z.string(),
        z.null()
    ]).optional()
});

/**
 * Author
 */
export const zAuthor = z.object({
    given_name: z.union([
        z.string(),
        z.null()
    ]).optional(),
    family_name: z.union([
        z.string(),
        z.null()
    ]).optional()
});

/**
 * Bell equation for \tau_m
 */
export const zBellFitMTau = z.object({
    type: z.literal('BellFitMTau').optional().default('BellFitMTau')
});

/**
 * Body_morphology_metrics_calculation_declared_register_morphology_with_calculated_metrics_post
 */
export const zBodyMorphologyMetricsCalculationDeclaredRegisterMorphologyWithCalculatedMetricsPost = z.object({
    file: z.string(),
    metadata: z.string().optional().default('{}')
});

/**
 * Body_test_neuron_file_declared_test_neuron_file_post
 */
export const zBodyTestNeuronFileDeclaredTestNeuronFilePost = z.object({
    file: z.string()
});

/**
 * Body_validate_mesh_file_declared_test_mesh_file_post
 */
export const zBodyValidateMeshFileDeclaredTestMeshFilePost = z.object({
    file: z.string()
});

/**
 * Body_validate_nwb_file_declared_validate_electrophysiology_protocol_nwb_file_post
 */
export const zBodyValidateNwbFileDeclaredValidateElectrophysiologyProtocolNwbFilePost = z.object({
    file: z.string()
});

/**
 * CellMorphology
 */
export const zCellMorphology = z.object({
    type: z.literal('CellMorphology').optional().default('CellMorphology'),
    name: z.string(),
    description: z.string(),
    species_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional(),
    strain_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional(),
    brain_region_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional()
});

/**
 * CellMorphologyFromID
 */
export const zCellMorphologyFromId = z.object({
    id_str: z.string(),
    type: z.literal('CellMorphologyFromID').optional().default('CellMorphologyFromID')
});

/**
 * Circuit
 *
 * Class representing a circuit.
 *
 * It points to a SONATA config and possible additional assets.
 */
export const zCircuit = z.object({
    name: z.string(),
    path: z.string(),
    matrix_path: z.union([
        z.string(),
        z.null()
    ]).optional(),
    type: z.literal('Circuit').optional().default('Circuit')
});

/**
 * CircuitFromID
 */
export const zCircuitFromId = z.object({
    id_str: z.string(),
    type: z.literal('CircuitFromID').optional().default('CircuitFromID')
});

/**
 * CircuitNodesetsResponse
 */
export const zCircuitNodesetsResponse = z.object({
    nodesets: z.array(z.string())
});

/**
 * CircuitPopulationsResponse
 */
export const zCircuitPopulationsResponse = z.object({
    populations: z.array(z.string())
});

/**
 * CircuitStatsLevelOfDetail
 */
export const zCircuitStatsLevelOfDetail = z.union([
    z.literal(0),
    z.literal(1),
    z.literal(2),
    z.literal(3)
]);

/**
 * ClusteredGroupedMorphologyLocations
 *
 * Clustered random locations, grouped in to conceptual groups.
 */
export const zClusteredGroupedMorphologyLocations = z.object({
    type: z.literal('ClusteredGroupedMorphologyLocations').optional().default('ClusteredGroupedMorphologyLocations'),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0),
    number_of_locations: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    section_types: z.union([
        z.array(z.number().int()),
        z.array(z.array(z.number().int())),
        z.null()
    ]).optional(),
    n_groups: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    n_clusters: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]),
    cluster_max_distance: z.union([
        z.number(),
        z.array(z.number())
    ])
});

/**
 * ClusteredMorphologyLocations
 *
 * Clustered random locations.
 */
export const zClusteredMorphologyLocations = z.object({
    type: z.literal('ClusteredMorphologyLocations').optional().default('ClusteredMorphologyLocations'),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0),
    number_of_locations: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    section_types: z.union([
        z.array(z.number().int()),
        z.array(z.array(z.number().int())),
        z.null()
    ]).optional(),
    n_clusters: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]),
    cluster_max_distance: z.union([
        z.number(),
        z.array(z.number())
    ])
});

/**
 * ClusteredPathDistanceMorphologyLocations
 *
 * Clustered random locations around a specified path distance. Also creates
 * groups within each cluster. This exposes the full possible complexity.
 */
export const zClusteredPathDistanceMorphologyLocations = z.object({
    type: z.literal('ClusteredPathDistanceMorphologyLocations').optional().default('ClusteredPathDistanceMorphologyLocations'),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0),
    number_of_locations: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    section_types: z.union([
        z.array(z.number().int()),
        z.array(z.array(z.number().int())),
        z.null()
    ]).optional(),
    n_clusters: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]),
    cluster_max_distance: z.union([
        z.number(),
        z.array(z.number())
    ]),
    path_dist_mean: z.union([
        z.number(),
        z.array(z.number())
    ]),
    path_dist_sd: z.union([
        z.number(),
        z.array(z.number())
    ]),
    n_groups_per_cluster: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * ConnectivityMetricsOutput
 */
export const zConnectivityMetricsOutput = z.object({
    connection_probability: z.union([
        z.record(z.unknown()),
        z.null()
    ]).optional(),
    mean_number_of_synapses: z.union([
        z.record(z.unknown()),
        z.null()
    ]).optional()
});

/**
 * ConnectivityMetricsRequest
 */
export const zConnectivityMetricsRequest = z.object({
    circuit_id: z.string(),
    edge_population: z.string(),
    pre_selection: z.union([
        z.record(z.union([
            z.string(),
            z.array(z.string())
        ])),
        z.null()
    ]).optional(),
    pre_node_set: z.union([
        z.string(),
        z.null()
    ]).optional(),
    post_selection: z.union([
        z.record(z.union([
            z.string(),
            z.array(z.string())
        ])),
        z.null()
    ]).optional(),
    post_node_set: z.union([
        z.string(),
        z.null()
    ]).optional(),
    group_by: z.union([
        z.string(),
        z.null()
    ]).optional(),
    max_distance: z.union([
        z.number().gt(0),
        z.null()
    ]).optional()
});

/**
 * Contribution
 */
export const zContribution = z.object({
    agent_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional(),
    role_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional()
});

/**
 * DegreeTypes
 */
export const zDegreeTypes = z.enum([
    'indegree',
    'outdegree',
    'totaldegree',
    'degreedifference'
]);

/**
 * EMCellMeshFromID
 */
export const zEmCellMeshFromId = z.object({
    id_str: z.string(),
    type: z.literal('EMCellMeshFromID').optional().default('EMCellMeshFromID')
});

/**
 * EdgePopulationType
 */
export const zEdgePopulationType = z.enum(['chemical', 'electrical']);

/**
 * CircuitMetricsEdgePopulation
 */
export const zCircuitMetricsEdgePopulation = z.object({
    number_of_edges: z.number().int(),
    name: z.string(),
    population_type: zEdgePopulationType,
    property_names: z.array(z.string()),
    property_stats: z.union([
        z.record(z.record(z.number())),
        z.null()
    ]),
    degree_stats: z.union([
        z.record(z.record(z.number())),
        z.null()
    ])
});

/**
 * ElectrophysiologyMetricsOutput
 *
 * Output schema for electrophysiological metrics extracted using BluePyEfe.
 */
export const zElectrophysiologyMetricsOutput = z.object({
    feature_dict: z.record(z.record(z.unknown()))
});

/**
 * All Excitatory Neurons
 *
 * All biophysical excitatory neurons.
 */
export const zExcitatoryNeurons = z.object({
    type: z.literal('ExcitatoryNeurons').optional().default('ExcitatoryNeurons'),
    sample_percentage: z.union([
        z.number().gte(0).lte(100),
        z.array(z.number().gte(0).lte(100)).min(1)
    ]).optional().default(100),
    sample_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * FloatRange
 */
export const zFloatRange = z.object({
    type: z.literal('FloatRange').optional().default('FloatRange'),
    start: z.number(),
    step: z.number().gt(0),
    end: z.number()
});

/**
 * GateExponents
 */
export const zGateExponents = z.object({
    type: z.literal('IonChannelFittingScanConfig.GateExponents').optional().default('IonChannelFittingScanConfig.GateExponents'),
    m_power: z.number().int().gte(1).lte(4).optional().default(1),
    h_power: z.number().int().gte(0).lte(4).optional().default(1)
});

/**
 * Info
 */
export const zInfo = z.object({
    type: z.literal('Info').optional().default('Info'),
    campaign_name: z.string().min(1),
    campaign_description: z.string().min(1)
});

/**
 * All Inhibitory Neurons
 *
 * All biophysical inhibitory neurons.
 */
export const zInhibitoryNeurons = z.object({
    type: z.literal('InhibitoryNeurons').optional().default('InhibitoryNeurons'),
    sample_percentage: z.union([
        z.number().gte(0).lte(100),
        z.array(z.number().gte(0).lte(100)).min(1)
    ]).optional().default(100),
    sample_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * Initialize
 */
export const zInitialize = z.object({
    type: z.literal('MorphologyDecontainerizationScanConfig.Initialize').optional().default('MorphologyDecontainerizationScanConfig.Initialize'),
    circuit: z.union([
        zCircuit,
        z.array(zCircuit)
    ]),
    output_format: z.union([
        z.enum([
            'h5',
            'asc',
            'swc'
        ]),
        z.array(z.enum([
            'h5',
            'asc',
            'swc'
        ]))
    ]).optional().default('h5')
});

/**
 * IntRange
 */
export const zIntRange = z.object({
    type: z.literal('IntRange').optional().default('IntRange'),
    start: z.number().int(),
    step: z.number().int().gt(0),
    end: z.number().int()
});

/**
 * IonChannelRecordingFromID
 */
export const zIonChannelRecordingFromId = z.object({
    id_str: z.string(),
    type: z.literal('IonChannelRecordingFromID').optional().default('IonChannelRecordingFromID')
});

/**
 * License
 */
export const zLicense = z.object({
    type: z.literal('License').optional().default('License'),
    license_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional()
});

/**
 * MEModelCircuit
 */
export const zMeModelCircuit = z.object({
    name: z.string(),
    path: z.string(),
    matrix_path: z.union([
        z.string(),
        z.null()
    ]).optional(),
    type: z.literal('MEModelCircuit').optional().default('MEModelCircuit')
});

/**
 * MEModelFromID
 */
export const zMeModelFromId = z.object({
    id_str: z.string(),
    type: z.literal('MEModelFromID').optional().default('MEModelFromID')
});

/**
 * MEModelWithSynapsesCircuit
 */
export const zMeModelWithSynapsesCircuit = z.object({
    name: z.string(),
    path: z.string(),
    matrix_path: z.union([
        z.string(),
        z.null()
    ]).optional(),
    type: z.literal('MEModelWithSynapsesCircuit').optional().default('MEModelWithSynapsesCircuit')
});

/**
 * MEModelWithSynapsesCircuitFromID
 */
export const zMeModelWithSynapsesCircuitFromId = z.object({
    id_str: z.string(),
    type: z.literal('MEModelWithSynapsesCircuitFromID').optional().default('MEModelWithSynapsesCircuitFromID')
});

/**
 * MTypeClassification
 */
export const zMTypeClassification = z.object({
    type: z.literal('MTypeClassification').optional().default('MTypeClassification'),
    mtype_class_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional()
});

/**
 * MorphologyDecontainerizationScanConfig
 *
 * Creates a circuit with individual morphology files instead of containerized morphologies,
 * which involves the following steps:
 * (1) Copy circuit to output location
 * (2) Extract individual .h5 morphologies from an .h5 container
 * (3) Convert .h5 morphologies to specified output format (.swc or .asc; skip if .h5)
 * (4) Update the circuit config, pointing to the individual morphology folder
 * (5) Delete .h5 container and .h5 files if that's not the specified output format
 * (7) Check loading individual morphologies
 * Important: The original circuit won't be modified! The circuit will be copied
 * to the output location where all operations take place.
 */
export const zMorphologyDecontainerizationScanConfig = z.object({
    type: z.literal('MorphologyDecontainerizationScanConfig').optional().default('MorphologyDecontainerizationScanConfig'),
    initialize: zInitialize
});

/**
 * MorphologyMetricsOutput
 */
export const zMorphologyMetricsOutput = z.object({
    aspect_ratio: z.union([
        z.number(),
        z.null()
    ]).optional(),
    circularity: z.union([
        z.number(),
        z.null()
    ]).optional(),
    length_fraction_above_soma: z.union([
        z.number(),
        z.null()
    ]).optional(),
    max_radial_distance: z.union([
        z.number(),
        z.null()
    ]).optional(),
    number_of_neurites: z.union([
        z.number().int(),
        z.null()
    ]).optional(),
    soma_radius: z.union([
        z.number(),
        z.null()
    ]).optional(),
    soma_surface_area: z.union([
        z.number(),
        z.null()
    ]).optional(),
    total_length: z.union([
        z.number(),
        z.null()
    ]).optional(),
    total_height: z.union([
        z.number(),
        z.null()
    ]).optional(),
    total_depth: z.union([
        z.number(),
        z.null()
    ]).optional(),
    total_area: z.union([
        z.number(),
        z.null()
    ]).optional(),
    total_volume: z.union([
        z.number(),
        z.null()
    ]).optional(),
    section_lengths: z.union([
        z.array(z.number()),
        z.null()
    ]).optional(),
    segment_radii: z.union([
        z.array(z.number()),
        z.null()
    ]).optional(),
    number_of_sections: z.union([
        z.number(),
        z.null()
    ]).optional(),
    local_bifurcation_angles: z.union([
        z.array(z.number()),
        z.null()
    ]).optional(),
    remote_bifurcation_angles: z.union([
        z.array(z.number()),
        z.null()
    ]).optional(),
    section_path_distances: z.union([
        z.array(z.number()),
        z.null()
    ]).optional(),
    section_radial_distances: z.union([
        z.array(z.number()),
        z.null()
    ]).optional(),
    section_branch_orders: z.union([
        z.array(z.number()),
        z.null()
    ]).optional(),
    section_strahler_orders: z.union([
        z.array(z.number()),
        z.null()
    ]).optional()
});

/**
 * NWBValidationResponse
 *
 * Schema for the NWB file validation success response.
 */
export const zNwbValidationResponse = z.object({
    status: z.string(),
    message: z.string()
});

/**
 * NamedPath
 *
 * Helper class to assign a name to a file path.
 */
export const zNamedPath = z.object({
    name: z.string(),
    path: z.string(),
    type: z.literal('NamedPath').optional().default('NamedPath')
});

/**
 * NamedTuple
 *
 * Helper class to assign a name to a tuple of elements.
 */
export const zNamedTuple = z.object({
    name: z.string().optional().default('Default name'),
    elements: z.array(z.number().int().gte(0)),
    type: z.literal('NamedTuple').optional().default('NamedTuple')
});

/**
 * ID Neuron Set
 *
 * Neuron set definition by providing a list of neuron IDs.
 */
export const zIdNeuronSet = z.object({
    type: z.literal('IDNeuronSet').optional().default('IDNeuronSet'),
    sample_percentage: z.union([
        z.number().gte(0).lte(100),
        z.array(z.number().gte(0).lte(100)).min(1)
    ]).optional().default(100),
    sample_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    neuron_ids: z.union([
        zNamedTuple,
        z.array(zNamedTuple).min(1)
    ])
});

/**
 * NeuronSetReference
 *
 * A reference to a NeuronSet block.
 */
export const zNeuronSetReference = z.object({
    block_dict_name: z.string().optional().default(''),
    block_name: z.string(),
    type: z.literal('NeuronSetReference').optional().default('NeuronSetReference')
});

/**
 * NodePopulationType
 */
export const zNodePopulationType = z.enum(['biophysical', 'virtual']);

/**
 * NonNegativeFloatRange
 */
export const zNonNegativeFloatRange = z.object({
    type: z.literal('NonNegativeFloatRange').optional().default('NonNegativeFloatRange'),
    start: z.number().gte(0),
    step: z.number().gt(0),
    end: z.number().gte(0)
});

/**
 * NonNegativeIntRange
 */
export const zNonNegativeIntRange = z.object({
    type: z.literal('NonNegativeIntRange').optional().default('NonNegativeIntRange'),
    start: z.number().int().gte(0),
    step: z.number().int().gt(0),
    end: z.number().int().gte(0)
});

/**
 * PathDistanceMorphologyLocations
 *
 * Locations around a specified path distance.
 */
export const zPathDistanceMorphologyLocations = z.object({
    type: z.literal('PathDistanceMorphologyLocations').optional().default('PathDistanceMorphologyLocations'),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0),
    number_of_locations: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    section_types: z.union([
        z.array(z.number().int()),
        z.array(z.array(z.number().int())),
        z.null()
    ]).optional(),
    path_dist_mean: z.union([
        z.number(),
        z.array(z.number())
    ]),
    path_dist_tolerance: z.union([
        z.number(),
        z.array(z.number())
    ])
});

/**
 * PositiveFloatRange
 */
export const zPositiveFloatRange = z.object({
    type: z.literal('PositiveFloatRange').optional().default('PositiveFloatRange'),
    start: z.number().gt(0),
    step: z.number().gt(0),
    end: z.number().gt(0)
});

/**
 * PositiveIntRange
 */
export const zPositiveIntRange = z.object({
    type: z.literal('PositiveIntRange').optional().default('PositiveIntRange'),
    start: z.number().int().gt(0),
    step: z.number().int().gt(0),
    end: z.number().int().gt(0)
});

/**
 * Predefined Neuron Set
 *
 * Use an existing node set already defined in the circuit's node sets file.
 */
export const zPredefinedNeuronSet = z.object({
    type: z.literal('PredefinedNeuronSet').optional().default('PredefinedNeuronSet'),
    sample_percentage: z.union([
        z.number().gte(0).lte(100),
        z.array(z.number().gte(0).lte(100)).min(1)
    ]).optional().default(100),
    sample_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    node_set: z.union([
        z.string().min(1),
        z.array(z.string().min(1))
    ])
});

/**
 * Publication
 */
export const zPublication = z.object({
    type: z.literal('Publication').optional().default('Publication'),
    name: z.string().optional().default(''),
    description: z.string().optional().default(''),
    DOI: z.union([
        z.string(),
        z.null()
    ]).optional().default(''),
    publication_title: z.union([
        z.string(),
        z.null()
    ]).optional().default(''),
    authors: z.union([
        zAuthor,
        z.null()
    ]).optional(),
    publication_year: z.union([
        z.number().int(),
        z.null()
    ]).optional(),
    abstract: z.union([
        z.string(),
        z.null()
    ]).optional().default('')
});

/**
 * RandomGroupedMorphologyLocations
 *
 * Completely random locations, but grouped into abstract groups.
 */
export const zRandomGroupedMorphologyLocations = z.object({
    type: z.literal('RandomGroupedMorphologyLocations').optional().default('RandomGroupedMorphologyLocations'),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0),
    number_of_locations: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    section_types: z.union([
        z.array(z.number().int()),
        z.array(z.array(z.number().int())),
        z.null()
    ]).optional(),
    n_groups: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * RandomMorphologyLocations
 *
 * Completely random locations without constraint.
 */
export const zRandomMorphologyLocations = z.object({
    type: z.literal('RandomMorphologyLocations').optional().default('RandomMorphologyLocations'),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0),
    number_of_locations: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    section_types: z.union([
        z.array(z.number().int()),
        z.array(z.array(z.number().int())),
        z.null()
    ]).optional()
});

/**
 * Regular Timestamps
 *
 * A series of timestamps at regular intervals.
 */
export const zRegularTimestamps = z.object({
    type: z.literal('RegularTimestamps').optional().default('RegularTimestamps'),
    start_time: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0),
    interval: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(10),
    number_of_repetitions: z.union([
        z.number().int().gte(0),
        z.array(z.number().int().gte(0))
    ]).optional().default(10)
});

/**
 * Demo: Scale U_SE to Modulate Acetylcholine Effect on Synaptic Release Probability
 *
 * Applying a scaling factor to the U_SE parameter.
 *
 * The U_SE parameter determines the effect of achetylcholine (ACh) on synaptic release
 * probability using the Tsodyks-Markram synaptic model. This is applied for all synapses
 * between biophysical neurons.
 */
export const zScaleAcetylcholineUseSynapticManipulation = z.object({
    type: z.literal('ScaleAcetylcholineUSESynapticManipulation').optional().default('ScaleAcetylcholineUSESynapticManipulation'),
    use_scaling: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0.7050728631217412)
});

/**
 * ScientificArtifact
 */
export const zScientificArtifact = z.object({
    type: z.literal('ScientificArtifact').optional().default('ScientificArtifact'),
    experiment_date: z.union([
        z.string().datetime(),
        z.null()
    ]).optional(),
    contact_email: z.union([
        z.string(),
        z.null()
    ]).optional(),
    atlas_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional()
});

/**
 * Sex
 */
export const zSex = z.enum([
    'male',
    'female',
    'unknown'
]);

/**
 * Sigmoid equation for h_{\infty}
 */
export const zSigFitHInf = z.object({
    type: z.literal('SigFitHInf').optional().default('SigFitHInf')
});

/**
 * Sigmoid equation for \tau_h
 */
export const zSigFitHTau = z.object({
    type: z.literal('SigFitHTau').optional().default('SigFitHTau')
});

/**
 * Sigmoid equation for m_{\infty}
 */
export const zSigFitMInf = z.object({
    type: z.literal('SigFitMInf').optional().default('SigFitMInf')
});

/**
 * Sigmoid equation combination for \tau_m
 */
export const zSigFitMTau = z.object({
    type: z.literal('SigFitMTau').optional().default('SigFitMTau')
});

/**
 * Single Timestamp
 *
 * A single timestamp at a specified time.
 */
export const zSingleTimestamp = z.object({
    type: z.literal('SingleTimestamp').optional().default('SingleTimestamp'),
    start_time: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0)
});

/**
 * Soma Voltage Recording (Full Experiment)
 *
 * Records the soma voltage of a neuron set for the full length of the experiment.
 */
export const zSomaVoltageRecording = z.object({
    type: z.literal('SomaVoltageRecording').optional().default('SomaVoltageRecording'),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    dt: z.union([
        z.number().gte(0.025),
        z.array(z.number().gte(0.025)),
        zNonNegativeFloatRange
    ]).optional().default(0.1)
});

/**
 * SpatialCoordinate
 */
export const zSpatialCoordinate = z.enum([
    'x',
    'y',
    'z'
]);

/**
 * CircuitMetricsNodePopulation
 */
export const zCircuitMetricsNodePopulation = z.object({
    number_of_nodes: z.number().int(),
    name: z.string(),
    population_type: zNodePopulationType,
    property_names: z.array(z.string()),
    property_unique_values: z.record(z.array(z.string())),
    property_value_counts: z.record(z.record(z.number().int())),
    node_location_info: z.union([
        z.record(z.record(z.number())),
        z.null()
    ])
});

/**
 * CircuitMetricsOutput
 */
export const zCircuitMetricsOutput = z.object({
    number_of_biophys_node_populations: z.number().int(),
    number_of_virtual_node_populations: z.number().int(),
    names_of_biophys_node_populations: z.array(z.string()),
    names_of_virtual_node_populations: z.array(z.string()),
    names_of_nodesets: z.array(z.string()),
    biophysical_node_populations: z.array(z.union([zCircuitMetricsNodePopulation, z.null()])),
    virtual_node_populations: z.array(z.union([zCircuitMetricsNodePopulation, z.null()])),
    number_of_chemical_edge_populations: z.number().int(),
    number_of_electrical_edge_populations: z.number().int(),
    names_of_chemical_edge_populations: z.array(z.string()),
    names_of_electrical_edge_populations: z.array(z.string()),
    chemical_edge_populations: z.array(z.union([zCircuitMetricsEdgePopulation, z.null()])),
    electrical_edge_populations: z.array(z.union([zCircuitMetricsEdgePopulation, z.null()]))
});

/**
 * Subject
 */
export const zSubject = z.object({
    type: z.literal('Subject').optional().default('Subject'),
    name: z.string(),
    description: z.string(),
    sex: zSex.optional().default('unknown'),
    weight: z.union([
        z.number().gt(0),
        z.null()
    ]).optional(),
    age_value: z.string(),
    age_min: z.union([
        z.string(),
        z.null()
    ]).optional(),
    age_max: z.union([
        z.string(),
        z.null()
    ]).optional(),
    age_period: z.union([
        zAgePeriod,
        z.null()
    ]).optional().default('unknown'),
    species_id: z.string().uuid(),
    strain_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional()
});

/**
 * ContributeSubjectScanConfig
 *
 * Contribute Morphology ScanConfig.
 */
export const zContributeSubjectScanConfig = z.object({
    type: z.literal('ContributeSubjectScanConfig').optional().default('ContributeSubjectScanConfig'),
    subject: zSubject.optional()
});

/**
 * SubjectID
 */
export const zSubjectId = z.object({
    type: z.literal('SubjectID').optional().default('SubjectID'),
    subject_id: z.union([
        z.string().uuid(),
        z.null()
    ]).optional()
});

/**
 * ContributeMorphologyScanConfig
 *
 * Contribute Morphology ScanConfig.
 */
export const zContributeMorphologyScanConfig = z.object({
    type: z.literal('ContributeMorphologyScanConfig').optional().default('ContributeMorphologyScanConfig'),
    assets: zAssets.optional(),
    contribution: zContribution.optional(),
    morphology: zCellMorphology.optional(),
    publication: zPublication.optional(),
    subject: zSubjectId.optional(),
    license: zLicense.optional(),
    scientificartifact: zScientificArtifact.optional(),
    mtype: zMTypeClassification.optional()
});

/**
 * Demo: Synaptic Mg2+ Concentration Manipulation
 *
 * Manipulate the extracellular synaptic magnesium (Mg2+) concentration.
 *
 * This is applied for all synapses between biophysical neurons.
 */
export const zSynapticMgManipulation = z.object({
    type: z.literal('SynapticMgManipulation').optional().default('SynapticMgManipulation'),
    magnesium_value: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(2.4)
});

/**
 * TaskType
 *
 * Task types supported for job submission.
 */
export const zTaskType = z.enum(['circuit_extraction', 'circuit_simulation']);

/**
 * TaskEstimateCreate
 *
 * Request model for task cost estimate.
 */
export const zTaskEstimateCreate = z.object({
    task_type: zTaskType,
    config_id: z.string().uuid()
});

/**
 * TaskLaunchCreate
 *
 * Request model for task launch.
 */
export const zTaskLaunchCreate = z.object({
    task_type: zTaskType,
    config_id: z.string().uuid()
});

/**
 * Double exponential denominator equation for \tau_m
 */
export const zThermoFitMTau = z.object({
    type: z.literal('ThermoFitMTau').optional().default('ThermoFitMTau')
});

/**
 * Double exponential denominator equation with slope constraint for \tau_m
 */
export const zThermoFitMTauV2 = z.object({
    type: z.literal('ThermoFitMTauV2').optional().default('ThermoFitMTauV2')
});

/**
 * Soma Voltage Recording (Time Window)
 *
 * Records the soma voltage of a neuron set over a specified time window.
 */
export const zTimeWindowSomaVoltageRecording = z.object({
    type: z.literal('TimeWindowSomaVoltageRecording').optional().default('TimeWindowSomaVoltageRecording'),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    dt: z.union([
        z.number().gte(0.025),
        z.array(z.number().gte(0.025)),
        zNonNegativeFloatRange
    ]).optional().default(0.1),
    start_time: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0),
    end_time: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(100)
});

/**
 * TimestampsReference
 *
 * A reference to a NeuronSet block.
 */
export const zTimestampsReference = z.object({
    block_dict_name: z.string().optional().default(''),
    block_name: z.string(),
    type: z.literal('TimestampsReference').optional().default('TimestampsReference')
});

/**
 * Constant Somatic Current Clamp (Absolute)
 *
 * A constant current injection at a fixed absolute amplitude.
 */
export const zConstantCurrentClampSomaticStimulus = z.object({
    type: z.literal('ConstantCurrentClampSomaticStimulus').optional().default('ConstantCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    amplitude: z.union([
        z.number(),
        z.array(z.number()),
        zFloatRange
    ]).optional().default(0.1)
});

/**
 * Fully Synchronous Spikes (Efferent)
 *
 * Spikes sent at the same time.
 *
 * Sent from all neurons in the source neuron set to efferently connected
 * neurons in the target neuron set.
 */
export const zFullySynchronousSpikeStimulus = z.object({
    type: z.literal('FullySynchronousSpikeStimulus').optional().default('FullySynchronousSpikeStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    source_neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    targeted_neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0)
});

/**
 * Hyperpolarizing Somatic Current Clamp
 *
 * A hyperpolarizing current injection which brings a cell to base membrance voltage.
 *
 * The holding current is pre-defined for each cell.
 */
export const zHyperpolarizingCurrentClampSomaticStimulus = z.object({
    type: z.literal('HyperpolarizingCurrentClampSomaticStimulus').optional().default('HyperpolarizingCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200)
});

/**
 * Linear Somatic Current Clamp (Absolute)
 *
 * A current injection which changes linearly in absolute ampltude over time.
 */
export const zLinearCurrentClampSomaticStimulus = z.object({
    type: z.literal('LinearCurrentClampSomaticStimulus').optional().default('LinearCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    amplitude_start: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0.1),
    amplitude_end: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0.2)
});

/**
 * Multi Pulse Somatic Current Clamp (Absolute)
 *
 * A series of current pulses injected at a fixed frequency, with each pulse having a fixed
 * absolute amplitude and temporal width.
 */
export const zMultiPulseCurrentClampSomaticStimulus = z.object({
    type: z.literal('MultiPulseCurrentClampSomaticStimulus').optional().default('MultiPulseCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    amplitude: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0.1),
    width: z.union([
        z.number().gte(0.000001),
        z.array(z.number().gte(0.000001))
    ]).optional().default(50),
    frequency: z.union([
        z.number().gte(0.000001),
        z.array(z.number().gte(0.000001))
    ]).optional().default(1)
});

/**
 * Normally Distributed Somatic Current Clamp (Absolute)
 *
 * Normally distributed current injection with a mean absolute amplitude.
 */
export const zNormallyDistributedCurrentClampSomaticStimulus = z.object({
    type: z.literal('NormallyDistributedCurrentClampSomaticStimulus').optional().default('NormallyDistributedCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    mean_amplitude: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0.01),
    variance: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0.01)
});

/**
 * Ornstein-Uhlenbeck Conductance Clamp (Absolute)
 *
 * A conductance injection based on the Ornstein-Uhlenbeck process.
 */
export const zOrnsteinUhlenbeckConductanceSomaticStimulus = z.object({
    type: z.literal('OrnsteinUhlenbeckConductanceSomaticStimulus').optional().default('OrnsteinUhlenbeckConductanceSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    time_constant: z.union([
        z.number().gt(0),
        z.array(z.number().gt(0))
    ]).optional().default(2.7),
    mean_amplitude: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0.001),
    standard_deviation: z.union([
        z.number().gt(0),
        z.array(z.number().gt(0))
    ]).optional().default(0.001),
    reversal_potential: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0)
});

/**
 * Ornstein-Uhlenbeck Current Clamp (Absolute)
 *
 * A current injection based on the Ornstein-Uhlenbeck process.
 */
export const zOrnsteinUhlenbeckCurrentSomaticStimulus = z.object({
    type: z.literal('OrnsteinUhlenbeckCurrentSomaticStimulus').optional().default('OrnsteinUhlenbeckCurrentSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    time_constant: z.union([
        z.number().gt(0),
        z.array(z.number().gt(0))
    ]).optional().default(2.7),
    mean_amplitude: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0.1),
    standard_deviation: z.union([
        z.number().gt(0),
        z.array(z.number().gt(0))
    ]).optional().default(0.05)
});

/**
 * Poisson Spikes (Efferent)
 *
 * Spike times drawn from a Poisson process with a given frequency.
 *
 * Sent from all neurons in the source neuron set to efferently connected
 * neurons in the target neuron set.
 */
export const zPoissonSpikeStimulus = z.object({
    type: z.literal('PoissonSpikeStimulus').optional().default('PoissonSpikeStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    source_neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    targeted_neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0).lte(5000),
        z.array(z.number().gte(0).lte(5000))
    ]).optional().default(200),
    frequency: z.union([
        z.number().gte(0.000001),
        z.array(z.number().gte(0.000001))
    ]).optional().default(1),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0)
});

/**
 * Constant Somatic Current Clamp (Relative)
 *
 * A constant current injection at a percentage of each cell's threshold current.
 */
export const zRelativeConstantCurrentClampSomaticStimulus = z.object({
    type: z.literal('RelativeConstantCurrentClampSomaticStimulus').optional().default('RelativeConstantCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    percentage_of_threshold_current: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(10)
});

/**
 * Linear Somatic Current Clamp (Relative)
 *
 * A current injection which changes linearly as a percentage of each cell's threshold current
 * over time.
 */
export const zRelativeLinearCurrentClampSomaticStimulus = z.object({
    type: z.literal('RelativeLinearCurrentClampSomaticStimulus').optional().default('RelativeLinearCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    percentage_of_threshold_current_start: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(10),
    percentage_of_threshold_current_end: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(100)
});

/**
 * Normally Distributed Somatic Current Clamp (Relative)
 *
 * Normally distributed current injection around a mean percentage of each cell's threshold
 * current.
 */
export const zRelativeNormallyDistributedCurrentClampSomaticStimulus = z.object({
    type: z.literal('RelativeNormallyDistributedCurrentClampSomaticStimulus').optional().default('RelativeNormallyDistributedCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    mean_percentage_of_threshold_current: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0.01),
    variance: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(0.01)
});

/**
 * Ornstein-Uhlenbeck Current Clamp (Relative)
 *
 * Ornstein-Uhlenbeck current injection as a percentage of each cell's threshold current.
 */
export const zRelativeOrnsteinUhlenbeckCurrentSomaticStimulus = z.object({
    type: z.literal('RelativeOrnsteinUhlenbeckCurrentSomaticStimulus').optional().default('RelativeOrnsteinUhlenbeckCurrentSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    time_constant: z.union([
        z.number().gt(0),
        z.array(z.number().gt(0))
    ]).optional().default(2.7),
    mean_percentage_of_threshold_current: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(100),
    standard_deviation_percentage_of_threshold: z.union([
        z.number().gt(0),
        z.array(z.number().gt(0))
    ]).optional().default(5)
});

/**
 * Sinusoidal Somatic Current Clamp (Absolute)
 *
 * A sinusoidal current injection with a fixed frequency and maximum absolute amplitude.
 */
export const zSinusoidalCurrentClampSomaticStimulus = z.object({
    type: z.literal('SinusoidalCurrentClampSomaticStimulus').optional().default('SinusoidalCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    maximum_amplitude: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0.1),
    frequency: z.union([
        z.number().gte(0.000001),
        z.array(z.number().gte(0.000001))
    ]).optional().default(1),
    dt: z.union([
        z.number().gte(0.025),
        z.array(z.number().gte(0.025))
    ]).optional().default(0.025)
});

/**
 * Sinusoidal Poisson Spikes (Efferent)
 *
 * Spike times drawn from an inhomogeneous Poisson process with sinusoidal rate.
 *
 * Sinusoid defined by a minimum and maximum rate.
 *
 * Sent from all neurons in the source neuron set to efferently connected
 * neurons in the target neuron set.
 */
export const zSinusoidalPoissonSpikeStimulus = z.object({
    type: z.literal('SinusoidalPoissonSpikeStimulus').optional().default('SinusoidalPoissonSpikeStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    source_neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    targeted_neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0).lte(5000),
        z.array(z.number().gte(0).lte(5000))
    ]).optional().default(200),
    minimum_rate: z.union([
        z.number().gt(0).lte(50),
        z.array(z.number().gt(0).lte(50))
    ]).optional().default(0.00001),
    maximum_rate: z.union([
        z.number().gt(0).lte(50),
        z.array(z.number().gt(0).lte(50))
    ]).optional().default(10),
    modulation_frequency_hz: z.union([
        z.number().gt(0).lte(100000),
        z.array(z.number().gt(0).lte(100000))
    ]).optional().default(5),
    phase_degrees: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(0)
});

/**
 * Subthreshold Somatic Current Clamp (Relative)
 *
 * A subthreshold current injection at a percentage below each cell's threshold current.
 */
export const zSubthresholdCurrentClampSomaticStimulus = z.object({
    type: z.literal('SubthresholdCurrentClampSomaticStimulus').optional().default('SubthresholdCurrentClampSomaticStimulus'),
    timestamps: z.union([
        zTimestampsReference,
        z.null()
    ]).optional(),
    neuron_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional(),
    timestamp_offset: z.union([
        z.number(),
        z.array(z.number()),
        z.null()
    ]).optional().default(0),
    duration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(200),
    percentage_below_threshold: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(0.1)
});

/**
 * ValidationError
 */
export const zValidationError = z.object({
    loc: z.array(z.union([z.string(), z.number().int()])),
    msg: z.string(),
    type: z.string()
});

/**
 * HTTPValidationError
 */
export const zHttpValidationError = z.object({
    detail: z.array(zValidationError).optional()
});

/**
 * ValidationStatus
 *
 * Enumeration of possible validation outcomes.
 */
export const zValidationStatus = z.enum(['success', 'failure']);

/**
 * MESHValidationResponse
 *
 * Schema for the MESH file validation success response.
 */
export const zMeshValidationResponse = z.object({
    status: zValidationStatus,
    message: z.string()
});

/**
 * Demo: nbS1 POm Inputs
 *
 * Virtual neurons projecting from the POm thalamic nucleus.
 *
 * Specifically, virtual neurons projecting from the POm thalamic nucleus to biophysical
 * cortical neurons in the nbS1 model.
 */
export const zNbS1pOmInputs = z.object({
    type: z.literal('nbS1POmInputs').optional().default('nbS1POmInputs'),
    sample_percentage: z.union([
        z.number().gte(0).lte(100),
        z.array(z.number().gte(0).lte(100)).min(1)
    ]).optional().default(100),
    sample_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * Demo: nbS1 VPM Inputs
 *
 * Virtual neurons projecting from the VPM thalamic nucleus.
 *
 * Specifically, virtual neurons projecting from the VPM thalamic nucleus to biophysical
 * cortical neurons in the nbS1 model.
 */
export const zNbS1VpmInputs = z.object({
    type: z.literal('nbS1VPMInputs').optional().default('nbS1VPMInputs'),
    sample_percentage: z.union([
        z.number().gte(0).lte(100),
        z.array(z.number().gte(0).lte(100)).min(1)
    ]).optional().default(100),
    sample_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * Initialize
 */
export const zObiOneScientificTasksBasicConnectivityPlotsBasicConnectivityPlotsScanConfigInitialize = z.object({
    type: z.literal('BasicConnectivityPlotsScanConfig.Initialize').optional().default('BasicConnectivityPlotsScanConfig.Initialize'),
    matrix_path: z.union([
        zNamedPath,
        z.array(zNamedPath)
    ]),
    plot_formats: z.array(z.string()).optional().default([
        'png',
        'pdf',
        'svg'
    ]),
    plot_types: z.array(z.string()).optional().default([
        'nodes',
        'connectivity_global',
        'connectivity_pathway',
        'small_adj_and_stats',
        'network_in_2D',
        'property_table'
    ]),
    rendering_cmap: z.union([
        z.string(),
        z.null()
    ]).optional(),
    rendering_color_file: z.union([
        z.string(),
        z.null()
    ]).optional(),
    dpi: z.number().int().optional().default(300)
});

/**
 * BasicConnectivityPlotsScanConfig
 *
 * Class to generate basic connectivity plots and stats from a ConnectivityMatrix object.
 *
 * Supported plot types:
 * - "nodes": Node statistics (e.g., synapse class, layer, mtype).
 * - "connectivity_pathway": Connection probabilities per pathway/grouping.
 * Not useful for small circuits.
 * - "connectivity_global": Global connection probabilities across the network.
 * Not useful for small circuits
 * - "small_adj_and_stats": Matrix and node statistics for small connectomes only (<= 20 nodes).
 * - "network_in_2D": 2D visualization of the network for small connectomes only (<= 20 nodes).
 * - "property_table": Table of node properties for small connectomes only (<= 20 nodes).
 */
export const zBasicConnectivityPlotsScanConfig = z.object({
    type: z.literal('BasicConnectivityPlotsScanConfig').optional().default('BasicConnectivityPlotsScanConfig'),
    initialize: zObiOneScientificTasksBasicConnectivityPlotsBasicConnectivityPlotsScanConfigInitialize
});

/**
 * Initialize
 */
export const zObiOneScientificTasksCircuitExtractionCircuitExtractionScanConfigInitialize = z.object({
    type: z.literal('CircuitExtractionScanConfig.Initialize').optional().default('CircuitExtractionScanConfig.Initialize'),
    circuit: z.union([
        z.union([
            z.object({
                type: z.literal('Circuit')
            }).and(zCircuit),
            z.object({
                type: z.literal('CircuitFromID')
            }).and(zCircuitFromId)
        ]),
        z.array(z.union([z.object({
                type: z.literal('Circuit')
            }).and(zCircuit), z.object({
                type: z.literal('CircuitFromID')
            }).and(zCircuitFromId)]))
    ]),
    do_virtual: z.boolean().optional().default(true),
    create_external: z.boolean().optional().default(true)
});

/**
 * CircuitExtractionScanConfig
 *
 * ScanConfig for extracting sub-circuits from larger circuits.
 */
export const zCircuitExtractionScanConfig = z.object({
    type: z.literal('CircuitExtractionScanConfig').optional().default('CircuitExtractionScanConfig'),
    info: zInfo,
    initialize: zObiOneScientificTasksCircuitExtractionCircuitExtractionScanConfigInitialize,
    neuron_set: z.union([
        z.object({
            type: z.literal('AllNeurons')
        }).and(zAllNeurons),
        z.object({
            type: z.literal('ExcitatoryNeurons')
        }).and(zExcitatoryNeurons),
        z.object({
            type: z.literal('InhibitoryNeurons')
        }).and(zInhibitoryNeurons),
        z.object({
            type: z.literal('PredefinedNeuronSet')
        }).and(zPredefinedNeuronSet),
        z.object({
            type: z.literal('IDNeuronSet')
        }).and(zIdNeuronSet)
    ])
});

/**
 * Initialize
 */
export const zObiOneScientificTasksConnectivityMatrixExtractionConnectivityMatrixExtractionScanConfigInitialize = z.object({
    type: z.literal('ConnectivityMatrixExtractionScanConfig.Initialize').optional().default('ConnectivityMatrixExtractionScanConfig.Initialize'),
    circuit: z.union([
        zCircuit,
        z.array(zCircuit)
    ]),
    edge_population: z.union([
        z.string(),
        z.array(z.union([z.string(), z.null()])),
        z.null()
    ]).optional(),
    node_attributes: z.union([
        z.array(z.string()),
        z.array(z.union([z.array(z.string()), z.null()])),
        z.null()
    ]).optional()
});

/**
 * ConnectivityMatrixExtractionScanConfig
 *
 * ScanConfig for extracting connectivity matrices in ConnectomeUtilities format.
 *
 * The connectivity matrix is extracted in ConnectomeUtilities format, consisting of a sparse
 * connectivity matrix with the number of synapses for each connection, together with a
 * table (dataframe) of selected node attributes.
 */
export const zConnectivityMatrixExtractionScanConfig = z.object({
    type: z.literal('ConnectivityMatrixExtractionScanConfig').optional().default('ConnectivityMatrixExtractionScanConfig'),
    initialize: zObiOneScientificTasksConnectivityMatrixExtractionConnectivityMatrixExtractionScanConfigInitialize
});

/**
 * Initialize
 */
export const zObiOneScientificTasksEphysExtractionElectrophysiologyMetricsScanConfigInitialize = z.object({
    type: z.literal('ElectrophysiologyMetricsScanConfig.Initialize').optional().default('ElectrophysiologyMetricsScanConfig.Initialize'),
    trace_id: z.string(),
    protocols: z.union([
        z.array(z.enum([
            'spontaneous',
            'idrest',
            'idthreshold',
            'apwaveform',
            'iv',
            'step',
            'sponaps',
            'firepattern',
            'spontaneousnohold',
            'starthold',
            'startnohold',
            'delta',
            'sahp',
            'idhyperpol',
            'irdepol',
            'irhyperpol',
            'iddepol',
            'apthreshold',
            'hyperdepol',
            'negcheops',
            'poscheops',
            'spikerec',
            'sinespec',
            'genericstep'
        ])),
        z.null()
    ]).optional(),
    requested_metrics: z.union([
        z.array(z.enum([
            'spike_count',
            'time_to_first_spike',
            'time_to_last_spike',
            'inv_time_to_first_spike',
            'doublet_ISI',
            'inv_first_ISI',
            'ISI_log_slope',
            'ISI_CV',
            'irregularity_index',
            'adaptation_index',
            'mean_frequency',
            'strict_burst_number',
            'strict_burst_mean_freq',
            'spikes_per_burst',
            'AP_height',
            'AP_amplitude',
            'AP1_amp',
            'APlast_amp',
            'AP_duration_half_width',
            'AHP_depth',
            'AHP_time_from_peak',
            'AP_peak_upstroke',
            'AP_peak_downstroke',
            'voltage_base',
            'voltage_after_stim',
            'ohmic_input_resistance_vb_ssse',
            'steady_state_voltage_stimend',
            'sag_amplitude',
            'decay_time_constant_after_stim',
            'depol_block_bool'
        ])),
        z.null()
    ]).optional(),
    amplitude: z.union([
        zAmplitudeInput,
        z.null()
    ]).optional()
});

/**
 * ElectrophysiologyMetricsScanConfig
 *
 * ScanConfig for extracting electrophysiological metrics from a trace.
 */
export const zElectrophysiologyMetricsScanConfig = z.object({
    type: z.literal('ElectrophysiologyMetricsScanConfig').optional().default('ElectrophysiologyMetricsScanConfig'),
    initialize: zObiOneScientificTasksEphysExtractionElectrophysiologyMetricsScanConfigInitialize
});

/**
 * Initialize
 */
export const zObiOneScientificTasksFolderCompressionFolderCompressionScanConfigInitialize = z.object({
    type: z.literal('FolderCompressionScanConfig.Initialize').optional().default('FolderCompressionScanConfig.Initialize'),
    folder_path: z.union([
        zNamedPath,
        z.array(zNamedPath)
    ]),
    file_format: z.union([
        z.string(),
        z.array(z.union([z.string(), z.null()])),
        z.null()
    ]).optional().default('gz'),
    file_name: z.union([
        z.string(),
        z.array(z.union([z.string(), z.null()])),
        z.null()
    ]).optional().default('compressed')
});

/**
 * FolderCompressionScanConfig
 *
 * Compression of an entire folder (e.g., circuit) using the given compression file format.
 *
 * The following compression formats are available: gzip (.gz; default), bzip2 (.bz2), LZMA (.xz)
 */
export const zFolderCompressionScanConfig = z.object({
    type: z.literal('FolderCompressionScanConfig').optional().default('FolderCompressionScanConfig'),
    initialize: zObiOneScientificTasksFolderCompressionFolderCompressionScanConfigInitialize
});

/**
 * Initialize
 */
export const zObiOneScientificTasksGenerateSimulationConfigsCircuitSimulationScanConfigInitialize = z.object({
    type: z.literal('CircuitSimulationScanConfig.Initialize').optional().default('CircuitSimulationScanConfig.Initialize'),
    circuit: z.union([
        z.union([
            z.object({
                type: z.literal('Circuit')
            }).and(zCircuit),
            z.object({
                type: z.literal('CircuitFromID')
            }).and(zCircuitFromId)
        ]),
        z.array(z.union([z.object({
                type: z.literal('Circuit')
            }).and(zCircuit), z.object({
                type: z.literal('CircuitFromID')
            }).and(zCircuitFromId)]))
    ]),
    simulation_length: z.union([
        z.number().gte(1).lte(5000),
        z.array(z.number().gte(1).lte(5000)).min(1)
    ]).optional().default(1000),
    extracellular_calcium_concentration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(1.1),
    v_init: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(-80),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    node_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional()
});

/**
 * CircuitSimulationScanConfig
 *
 * CircuitSimulationScanConfig.
 */
export const zCircuitSimulationScanConfig = z.object({
    type: z.literal('CircuitSimulationScanConfig').optional().default('CircuitSimulationScanConfig'),
    timestamps: z.record(z.union([
        z.object({
            type: z.literal('SingleTimestamp')
        }).and(zSingleTimestamp),
        z.object({
            type: z.literal('RegularTimestamps')
        }).and(zRegularTimestamps)
    ])).optional(),
    recordings: z.record(z.union([
        z.object({
            type: z.literal('SomaVoltageRecording')
        }).and(zSomaVoltageRecording),
        z.object({
            type: z.literal('TimeWindowSomaVoltageRecording')
        }).and(zTimeWindowSomaVoltageRecording)
    ])).optional(),
    info: zInfo,
    neuron_sets: z.record(z.union([
        z.object({
            type: z.literal('IDNeuronSet')
        }).and(zIdNeuronSet),
        z.object({
            type: z.literal('AllNeurons')
        }).and(zAllNeurons),
        z.object({
            type: z.literal('ExcitatoryNeurons')
        }).and(zExcitatoryNeurons),
        z.object({
            type: z.literal('InhibitoryNeurons')
        }).and(zInhibitoryNeurons),
        z.object({
            type: z.literal('PredefinedNeuronSet')
        }).and(zPredefinedNeuronSet),
        z.object({
            type: z.literal('nbS1VPMInputs')
        }).and(zNbS1VpmInputs),
        z.object({
            type: z.literal('nbS1POmInputs')
        }).and(zNbS1pOmInputs)
    ])).optional(),
    synaptic_manipulations: z.record(z.union([
        z.object({
            type: z.literal('SynapticMgManipulation')
        }).and(zSynapticMgManipulation),
        z.object({
            type: z.literal('ScaleAcetylcholineUSESynapticManipulation')
        }).and(zScaleAcetylcholineUseSynapticManipulation)
    ])).optional(),
    initialize: zObiOneScientificTasksGenerateSimulationConfigsCircuitSimulationScanConfigInitialize,
    stimuli: z.record(z.union([
        z.object({
            type: z.literal('ConstantCurrentClampSomaticStimulus')
        }).and(zConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('HyperpolarizingCurrentClampSomaticStimulus')
        }).and(zHyperpolarizingCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('LinearCurrentClampSomaticStimulus')
        }).and(zLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('MultiPulseCurrentClampSomaticStimulus')
        }).and(zMultiPulseCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('NormallyDistributedCurrentClampSomaticStimulus')
        }).and(zNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeNormallyDistributedCurrentClampSomaticStimulus')
        }).and(zRelativeNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeConstantCurrentClampSomaticStimulus')
        }).and(zRelativeConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeLinearCurrentClampSomaticStimulus')
        }).and(zRelativeLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SinusoidalCurrentClampSomaticStimulus')
        }).and(zSinusoidalCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SubthresholdCurrentClampSomaticStimulus')
        }).and(zSubthresholdCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zOrnsteinUhlenbeckCurrentSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckConductanceSomaticStimulus')
        }).and(zOrnsteinUhlenbeckConductanceSomaticStimulus),
        z.object({
            type: z.literal('RelativeOrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zRelativeOrnsteinUhlenbeckCurrentSomaticStimulus),
        z.object({
            type: z.literal('PoissonSpikeStimulus')
        }).and(zPoissonSpikeStimulus),
        z.object({
            type: z.literal('FullySynchronousSpikeStimulus')
        }).and(zFullySynchronousSpikeStimulus),
        z.object({
            type: z.literal('SinusoidalPoissonSpikeStimulus')
        }).and(zSinusoidalPoissonSpikeStimulus)
    ])).optional()
});

/**
 * Initialize
 */
export const zObiOneScientificTasksGenerateSimulationConfigsMeModelSimulationScanConfigInitialize = z.object({
    type: z.literal('MEModelSimulationScanConfig.Initialize').optional().default('MEModelSimulationScanConfig.Initialize'),
    circuit: z.union([
        z.union([
            z.object({
                type: z.literal('MEModelCircuit')
            }).and(zMeModelCircuit),
            z.object({
                type: z.literal('MEModelFromID')
            }).and(zMeModelFromId)
        ]),
        z.array(z.union([z.object({
                type: z.literal('MEModelCircuit')
            }).and(zMeModelCircuit), z.object({
                type: z.literal('MEModelFromID')
            }).and(zMeModelFromId)]))
    ]),
    simulation_length: z.union([
        z.number().gte(1).lte(5000),
        z.array(z.number().gte(1).lte(5000)).min(1)
    ]).optional().default(1000),
    extracellular_calcium_concentration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(1.1),
    v_init: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(-80),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * MEModelSimulationScanConfig
 *
 * MEModelSimulationScanConfig.
 */
export const zMeModelSimulationScanConfig = z.object({
    type: z.literal('MEModelSimulationScanConfig').optional().default('MEModelSimulationScanConfig'),
    timestamps: z.record(z.union([
        z.object({
            type: z.literal('SingleTimestamp')
        }).and(zSingleTimestamp),
        z.object({
            type: z.literal('RegularTimestamps')
        }).and(zRegularTimestamps)
    ])).optional(),
    recordings: z.record(z.union([
        z.object({
            type: z.literal('SomaVoltageRecording')
        }).and(zSomaVoltageRecording),
        z.object({
            type: z.literal('TimeWindowSomaVoltageRecording')
        }).and(zTimeWindowSomaVoltageRecording)
    ])).optional(),
    info: zInfo,
    initialize: zObiOneScientificTasksGenerateSimulationConfigsMeModelSimulationScanConfigInitialize,
    stimuli: z.record(z.union([
        z.object({
            type: z.literal('ConstantCurrentClampSomaticStimulus')
        }).and(zConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('HyperpolarizingCurrentClampSomaticStimulus')
        }).and(zHyperpolarizingCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('LinearCurrentClampSomaticStimulus')
        }).and(zLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('MultiPulseCurrentClampSomaticStimulus')
        }).and(zMultiPulseCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('NormallyDistributedCurrentClampSomaticStimulus')
        }).and(zNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeNormallyDistributedCurrentClampSomaticStimulus')
        }).and(zRelativeNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeConstantCurrentClampSomaticStimulus')
        }).and(zRelativeConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeLinearCurrentClampSomaticStimulus')
        }).and(zRelativeLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SinusoidalCurrentClampSomaticStimulus')
        }).and(zSinusoidalCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SubthresholdCurrentClampSomaticStimulus')
        }).and(zSubthresholdCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zOrnsteinUhlenbeckCurrentSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckConductanceSomaticStimulus')
        }).and(zOrnsteinUhlenbeckConductanceSomaticStimulus),
        z.object({
            type: z.literal('RelativeOrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zRelativeOrnsteinUhlenbeckCurrentSomaticStimulus)
    ])).optional()
});

/**
 * Initialize
 */
export const zObiOneScientificTasksGenerateSimulationConfigsMeModelWithSynapsesCircuitSimulationScanConfigInitialize = z.object({
    type: z.literal('MEModelWithSynapsesCircuitSimulationScanConfig.Initialize').optional().default('MEModelWithSynapsesCircuitSimulationScanConfig.Initialize'),
    circuit: z.union([
        z.union([
            z.object({
                type: z.literal('MEModelWithSynapsesCircuit')
            }).and(zMeModelWithSynapsesCircuit),
            z.object({
                type: z.literal('MEModelWithSynapsesCircuitFromID')
            }).and(zMeModelWithSynapsesCircuitFromId)
        ]),
        z.array(z.union([z.object({
                type: z.literal('MEModelWithSynapsesCircuit')
            }).and(zMeModelWithSynapsesCircuit), z.object({
                type: z.literal('MEModelWithSynapsesCircuitFromID')
            }).and(zMeModelWithSynapsesCircuitFromId)]))
    ]),
    simulation_length: z.union([
        z.number().gte(1).lte(5000),
        z.array(z.number().gte(1).lte(5000)).min(1)
    ]).optional().default(1000),
    extracellular_calcium_concentration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(1.1),
    v_init: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(-80),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1)
});

/**
 * MEModelWithSynapsesCircuitSimulationScanConfig
 *
 * MEModelWithSynapsesCircuitSimulationScanConfig.
 */
export const zMeModelWithSynapsesCircuitSimulationScanConfig = z.object({
    type: z.literal('MEModelWithSynapsesCircuitSimulationScanConfig').optional().default('MEModelWithSynapsesCircuitSimulationScanConfig'),
    timestamps: z.record(z.union([
        z.object({
            type: z.literal('SingleTimestamp')
        }).and(zSingleTimestamp),
        z.object({
            type: z.literal('RegularTimestamps')
        }).and(zRegularTimestamps)
    ])).optional(),
    recordings: z.record(z.union([
        z.object({
            type: z.literal('SomaVoltageRecording')
        }).and(zSomaVoltageRecording),
        z.object({
            type: z.literal('TimeWindowSomaVoltageRecording')
        }).and(zTimeWindowSomaVoltageRecording)
    ])).optional(),
    info: zInfo,
    neuron_sets: z.record(z.union([
        z.object({
            type: z.literal('nbS1VPMInputs')
        }).and(zNbS1VpmInputs),
        z.object({
            type: z.literal('nbS1POmInputs')
        }).and(zNbS1pOmInputs)
    ])).optional(),
    synaptic_manipulations: z.record(z.union([
        z.object({
            type: z.literal('SynapticMgManipulation')
        }).and(zSynapticMgManipulation),
        z.object({
            type: z.literal('ScaleAcetylcholineUSESynapticManipulation')
        }).and(zScaleAcetylcholineUseSynapticManipulation)
    ])).optional(),
    initialize: zObiOneScientificTasksGenerateSimulationConfigsMeModelWithSynapsesCircuitSimulationScanConfigInitialize,
    stimuli: z.record(z.union([
        z.object({
            type: z.literal('ConstantCurrentClampSomaticStimulus')
        }).and(zConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('HyperpolarizingCurrentClampSomaticStimulus')
        }).and(zHyperpolarizingCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('LinearCurrentClampSomaticStimulus')
        }).and(zLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('MultiPulseCurrentClampSomaticStimulus')
        }).and(zMultiPulseCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('NormallyDistributedCurrentClampSomaticStimulus')
        }).and(zNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeNormallyDistributedCurrentClampSomaticStimulus')
        }).and(zRelativeNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeConstantCurrentClampSomaticStimulus')
        }).and(zRelativeConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeLinearCurrentClampSomaticStimulus')
        }).and(zRelativeLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SinusoidalCurrentClampSomaticStimulus')
        }).and(zSinusoidalCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SubthresholdCurrentClampSomaticStimulus')
        }).and(zSubthresholdCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zOrnsteinUhlenbeckCurrentSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckConductanceSomaticStimulus')
        }).and(zOrnsteinUhlenbeckConductanceSomaticStimulus),
        z.object({
            type: z.literal('RelativeOrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zRelativeOrnsteinUhlenbeckCurrentSomaticStimulus),
        z.object({
            type: z.literal('PoissonSpikeStimulus')
        }).and(zPoissonSpikeStimulus),
        z.object({
            type: z.literal('FullySynchronousSpikeStimulus')
        }).and(zFullySynchronousSpikeStimulus),
        z.object({
            type: z.literal('SinusoidalPoissonSpikeStimulus')
        }).and(zSinusoidalPoissonSpikeStimulus)
    ])).optional()
});

/**
 * Initialize
 */
export const zObiOneScientificTasksIonChannelModelingIonChannelFittingScanConfigInitialize = z.object({
    type: z.literal('IonChannelFittingScanConfig.Initialize').optional().default('IonChannelFittingScanConfig.Initialize'),
    recordings: zIonChannelRecordingFromId,
    ion_channel_name: z.string().min(1).regex(/^[A-Za-z_][A-Za-z0-9_]*$/).optional().default('DefaultIonChannelName')
});

/**
 * IonChannelFittingScanConfig
 *
 * Form for modeling an ion channel model from a set of ion channel traces.
 */
export const zIonChannelFittingScanConfig = z.object({
    type: z.literal('IonChannelFittingScanConfig').optional().default('IonChannelFittingScanConfig'),
    initialize: zObiOneScientificTasksIonChannelModelingIonChannelFittingScanConfigInitialize,
    info: zInfo,
    minf_eq: z.union([
        z.object({
            type: z.literal('SigFitMInf')
        }).and(zSigFitMInf),
        z.null()
    ]),
    mtau_eq: z.union([
        z.object({
            type: z.literal('SigFitMTau')
        }).and(zSigFitMTau),
        z.object({
            type: z.literal('ThermoFitMTau')
        }).and(zThermoFitMTau),
        z.object({
            type: z.literal('ThermoFitMTauV2')
        }).and(zThermoFitMTauV2),
        z.object({
            type: z.literal('BellFitMTau')
        }).and(zBellFitMTau)
    ]),
    hinf_eq: z.union([
        z.object({
            type: z.literal('SigFitHInf')
        }).and(zSigFitHInf),
        z.null()
    ]),
    htau_eq: z.union([
        z.object({
            type: z.literal('SigFitHTau')
        }).and(zSigFitHTau),
        z.null()
    ]),
    gate_exponents: zGateExponents
});

/**
 * Initialize
 */
export const zObiOneScientificTasksMorphologyContainerizationMorphologyContainerizationScanConfigInitialize = z.object({
    type: z.literal('MorphologyContainerizationScanConfig.Initialize').optional().default('MorphologyContainerizationScanConfig.Initialize'),
    circuit: z.union([
        zCircuit,
        z.array(zCircuit)
    ]),
    hoc_template_old: z.string(),
    hoc_template_new: z.string()
});

/**
 * MorphologyContainerizationScanConfig
 *
 * Creates a circuit with containerized morphologies instead of individual morphology files,
 * which involves the following steps:
 * (1) Copy circuit to output location
 * (2) Convert morphologies to .h5, if not yet existing (from .swc or .asc)
 * (3) Merge individual .h5 morphologies into an .h5 container
 * (4) Update the circuit config, pointing to the .h5 container
 * (5) Update .hoc files so that they will work with .h5 containers
 * (6) Delete all individual morphologies
 * (7) Check containerized morphologies
 * Important: The original circuit won't be modified! The circuit will be copied
 * to the output location where all operations take place.
 */
export const zMorphologyContainerizationScanConfig = z.object({
    type: z.literal('MorphologyContainerizationScanConfig').optional().default('MorphologyContainerizationScanConfig'),
    initialize: zObiOneScientificTasksMorphologyContainerizationMorphologyContainerizationScanConfigInitialize
});

/**
 * Initialize
 */
export const zObiOneScientificTasksMorphologyLocationsMorphologyLocationsScanConfigInitialize = z.object({
    type: z.literal('MorphologyLocationsScanConfig.Initialize').optional().default('MorphologyLocationsScanConfig.Initialize'),
    morphology: z.union([
        zCellMorphologyFromId,
        z.array(zCellMorphologyFromId),
        z.string(),
        z.array(z.string())
    ])
});

/**
 * MorphologyLocationsScanConfig
 *
 * ScanConfig for generating locations on a morphology skeleton.
 */
export const zMorphologyLocationsScanConfig = z.object({
    type: z.literal('MorphologyLocationsScanConfig').optional().default('MorphologyLocationsScanConfig'),
    initialize: zObiOneScientificTasksMorphologyLocationsMorphologyLocationsScanConfigInitialize,
    morph_locations: z.union([
        z.object({
            type: z.literal('ClusteredGroupedMorphologyLocations')
        }).and(zClusteredGroupedMorphologyLocations),
        z.object({
            type: z.literal('ClusteredMorphologyLocations')
        }).and(zClusteredMorphologyLocations),
        z.object({
            type: z.literal('ClusteredPathDistanceMorphologyLocations')
        }).and(zClusteredPathDistanceMorphologyLocations),
        z.object({
            type: z.literal('PathDistanceMorphologyLocations')
        }).and(zPathDistanceMorphologyLocations),
        z.object({
            type: z.literal('RandomGroupedMorphologyLocations')
        }).and(zRandomGroupedMorphologyLocations),
        z.object({
            type: z.literal('RandomMorphologyLocations')
        }).and(zRandomMorphologyLocations)
    ])
});

/**
 * Initialize
 */
export const zObiOneScientificTasksMorphologyMetricsMorphologyMetricsScanConfigInitialize = z.object({
    type: z.literal('MorphologyMetricsScanConfig.Initialize').optional().default('MorphologyMetricsScanConfig.Initialize'),
    morphology: z.union([
        zCellMorphologyFromId,
        z.array(zCellMorphologyFromId)
    ])
});

/**
 * MorphologyMetricsScanConfig
 */
export const zMorphologyMetricsScanConfig = z.object({
    type: z.literal('MorphologyMetricsScanConfig').optional().default('MorphologyMetricsScanConfig'),
    initialize: zObiOneScientificTasksMorphologyMetricsMorphologyMetricsScanConfigInitialize
});

/**
 * Initialize
 */
export const zObiOneScientificTasksSkeletonizationSkeletonizationScanConfigInitialize = z.object({
    type: z.literal('SkeletonizationScanConfig.Initialize').optional().default('SkeletonizationScanConfig.Initialize'),
    cell_mesh: z.union([
        zEmCellMeshFromId,
        z.array(zEmCellMeshFromId)
    ]),
    neuron_voxel_size: z.union([
        z.number().gt(0).lte(0.5),
        z.array(z.number().gt(0).lte(0.5))
    ]).optional().default(0.1),
    spines_voxel_size: z.union([
        z.number().gt(0).lte(0.5),
        z.array(z.number().gt(0).lte(0.5))
    ]).optional().default(0.1)
});

/**
 * SkeletonizationScanConfig
 *
 * Abstract base class for skeletonization scan configurations.
 */
export const zSkeletonizationScanConfig = z.object({
    type: z.literal('SkeletonizationScanConfig').optional().default('SkeletonizationScanConfig'),
    info: zInfo,
    initialize: zObiOneScientificTasksSkeletonizationSkeletonizationScanConfigInitialize
});

/**
 * Initialize
 */
export const zObiOneScientificUnionsAliasesSimulationsFormInitialize = z.object({
    type: z.literal('SimulationsForm.Initialize').optional().default('SimulationsForm.Initialize'),
    circuit: z.union([
        z.union([
            z.object({
                type: z.literal('Circuit')
            }).and(zCircuit),
            z.object({
                type: z.literal('CircuitFromID')
            }).and(zCircuitFromId)
        ]),
        z.array(z.union([z.object({
                type: z.literal('Circuit')
            }).and(zCircuit), z.object({
                type: z.literal('CircuitFromID')
            }).and(zCircuitFromId)]))
    ]),
    simulation_length: z.union([
        z.number().gte(1).lte(5000),
        z.array(z.number().gte(1).lte(5000)).min(1)
    ]).optional().default(1000),
    extracellular_calcium_concentration: z.union([
        z.number().gte(0),
        z.array(z.number().gte(0))
    ]).optional().default(1.1),
    v_init: z.union([
        z.number(),
        z.array(z.number())
    ]).optional().default(-80),
    random_seed: z.union([
        z.number().int(),
        z.array(z.number().int())
    ]).optional().default(1),
    node_set: z.union([
        zNeuronSetReference,
        z.null()
    ]).optional()
});

/**
 * SimulationsForm
 */
export const zSimulationsForm = z.object({
    type: z.literal('SimulationsForm').optional().default('SimulationsForm'),
    timestamps: z.record(z.union([
        z.object({
            type: z.literal('SingleTimestamp')
        }).and(zSingleTimestamp),
        z.object({
            type: z.literal('RegularTimestamps')
        }).and(zRegularTimestamps)
    ])).optional(),
    recordings: z.record(z.union([
        z.object({
            type: z.literal('SomaVoltageRecording')
        }).and(zSomaVoltageRecording),
        z.object({
            type: z.literal('TimeWindowSomaVoltageRecording')
        }).and(zTimeWindowSomaVoltageRecording)
    ])).optional(),
    info: zInfo,
    neuron_sets: z.record(z.union([
        z.object({
            type: z.literal('IDNeuronSet')
        }).and(zIdNeuronSet),
        z.object({
            type: z.literal('AllNeurons')
        }).and(zAllNeurons),
        z.object({
            type: z.literal('ExcitatoryNeurons')
        }).and(zExcitatoryNeurons),
        z.object({
            type: z.literal('InhibitoryNeurons')
        }).and(zInhibitoryNeurons),
        z.object({
            type: z.literal('PredefinedNeuronSet')
        }).and(zPredefinedNeuronSet),
        z.object({
            type: z.literal('nbS1VPMInputs')
        }).and(zNbS1VpmInputs),
        z.object({
            type: z.literal('nbS1POmInputs')
        }).and(zNbS1pOmInputs)
    ])).optional(),
    synaptic_manipulations: z.record(z.union([
        z.object({
            type: z.literal('SynapticMgManipulation')
        }).and(zSynapticMgManipulation),
        z.object({
            type: z.literal('ScaleAcetylcholineUSESynapticManipulation')
        }).and(zScaleAcetylcholineUseSynapticManipulation)
    ])).optional(),
    initialize: zObiOneScientificUnionsAliasesSimulationsFormInitialize,
    stimuli: z.record(z.union([
        z.object({
            type: z.literal('ConstantCurrentClampSomaticStimulus')
        }).and(zConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('HyperpolarizingCurrentClampSomaticStimulus')
        }).and(zHyperpolarizingCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('LinearCurrentClampSomaticStimulus')
        }).and(zLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('MultiPulseCurrentClampSomaticStimulus')
        }).and(zMultiPulseCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('NormallyDistributedCurrentClampSomaticStimulus')
        }).and(zNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeNormallyDistributedCurrentClampSomaticStimulus')
        }).and(zRelativeNormallyDistributedCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeConstantCurrentClampSomaticStimulus')
        }).and(zRelativeConstantCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('RelativeLinearCurrentClampSomaticStimulus')
        }).and(zRelativeLinearCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SinusoidalCurrentClampSomaticStimulus')
        }).and(zSinusoidalCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('SubthresholdCurrentClampSomaticStimulus')
        }).and(zSubthresholdCurrentClampSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zOrnsteinUhlenbeckCurrentSomaticStimulus),
        z.object({
            type: z.literal('OrnsteinUhlenbeckConductanceSomaticStimulus')
        }).and(zOrnsteinUhlenbeckConductanceSomaticStimulus),
        z.object({
            type: z.literal('RelativeOrnsteinUhlenbeckCurrentSomaticStimulus')
        }).and(zRelativeOrnsteinUhlenbeckCurrentSomaticStimulus),
        z.object({
            type: z.literal('PoissonSpikeStimulus')
        }).and(zPoissonSpikeStimulus),
        z.object({
            type: z.literal('FullySynchronousSpikeStimulus')
        }).and(zFullySynchronousSpikeStimulus),
        z.object({
            type: z.literal('SinusoidalPoissonSpikeStimulus')
        }).and(zSinusoidalPoissonSpikeStimulus)
    ])).optional()
});

export const zRootGetData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Response Root  Get
 *
 * Successful Response
 */
export const zRootGetResponse = z.record(z.unknown());

export const zHealthHealthGetData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Response Health Health Get
 *
 * Successful Response
 */
export const zHealthHealthGetResponse = z.record(z.unknown());

export const zVersionVersionGetData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Response Version Version Get
 *
 * Successful Response
 */
export const zVersionVersionGetResponse = z.record(z.unknown());

export const zConnectivityMetricsEndpointDeclaredConnectivityMetricsPostData = z.object({
    body: zConnectivityMetricsRequest,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zConnectivityMetricsEndpointDeclaredConnectivityMetricsPostResponse = zConnectivityMetricsOutput;

export const zCircuitMetricsEndpointDeclaredCircuitMetricsCircuitIdGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        circuit_id: z.string()
    }),
    query: z.object({
        level_of_detail_nodes: zCircuitStatsLevelOfDetail.optional().default(0),
        level_of_detail_edges: zCircuitStatsLevelOfDetail.optional().default(0)
    }).optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zCircuitMetricsEndpointDeclaredCircuitMetricsCircuitIdGetResponse = zCircuitMetricsOutput;

export const zCircuitPopulationsEndpointDeclaredCircuitCircuitIdBiophysicalPopulationsGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        circuit_id: z.string()
    }),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zCircuitPopulationsEndpointDeclaredCircuitCircuitIdBiophysicalPopulationsGetResponse = zCircuitPopulationsResponse;

export const zCircuitNodesetsEndpointDeclaredCircuitCircuitIdNodesetsGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        circuit_id: z.string()
    }),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zCircuitNodesetsEndpointDeclaredCircuitCircuitIdNodesetsGetResponse = zCircuitNodesetsResponse;

export const zMappedCircuitPropertiesEndpointDeclaredMappedCircuitPropertiesCircuitIdGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        circuit_id: z.string()
    }),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Mapped Circuit Properties Endpoint Declared Mapped Circuit Properties  Circuit Id  Get
 *
 * Successful Response
 */
export const zMappedCircuitPropertiesEndpointDeclaredMappedCircuitPropertiesCircuitIdGetResponse = z.record(z.unknown());

export const zGridScanParametersCountEndpointDeclaredScanConfigGridScanCoordinateCountPostData = z.object({
    body: z.union([
        z.object({
            type: z.literal('CircuitSimulationScanConfig')
        }).and(zCircuitSimulationScanConfig),
        z.object({
            type: z.literal('SimulationsForm')
        }).and(zSimulationsForm),
        z.object({
            type: z.literal('CircuitExtractionScanConfig')
        }).and(zCircuitExtractionScanConfig),
        z.object({
            type: z.literal('BasicConnectivityPlotsScanConfig')
        }).and(zBasicConnectivityPlotsScanConfig),
        z.object({
            type: z.literal('ConnectivityMatrixExtractionScanConfig')
        }).and(zConnectivityMatrixExtractionScanConfig),
        z.object({
            type: z.literal('ContributeMorphologyScanConfig')
        }).and(zContributeMorphologyScanConfig),
        z.object({
            type: z.literal('FolderCompressionScanConfig')
        }).and(zFolderCompressionScanConfig),
        z.object({
            type: z.literal('MEModelSimulationScanConfig')
        }).and(zMeModelSimulationScanConfig),
        z.object({
            type: z.literal('MorphologyContainerizationScanConfig')
        }).and(zMorphologyContainerizationScanConfig),
        z.object({
            type: z.literal('ElectrophysiologyMetricsScanConfig')
        }).and(zElectrophysiologyMetricsScanConfig),
        z.object({
            type: z.literal('MorphologyDecontainerizationScanConfig')
        }).and(zMorphologyDecontainerizationScanConfig),
        z.object({
            type: z.literal('MorphologyMetricsScanConfig')
        }).and(zMorphologyMetricsScanConfig),
        z.object({
            type: z.literal('MorphologyLocationsScanConfig')
        }).and(zMorphologyLocationsScanConfig),
        z.object({
            type: z.literal('IonChannelFittingScanConfig')
        }).and(zIonChannelFittingScanConfig),
        z.object({
            type: z.literal('SkeletonizationScanConfig')
        }).and(zSkeletonizationScanConfig),
        z.object({
            type: z.literal('MEModelWithSynapsesCircuitSimulationScanConfig')
        }).and(zMeModelWithSynapsesCircuitSimulationScanConfig)
    ]),
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Grid Scan Parameters Count Endpoint Declared Scan Config Grid Scan Coordinate Count Post
 *
 * Successful Response
 */
export const zGridScanParametersCountEndpointDeclaredScanConfigGridScanCoordinateCountPostResponse = z.number().int();

export const zElectrophysiologyrecordingMetricsEndpointDeclaredElectrophysiologyrecordingMetricsTraceIdGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        trace_id: z.string()
    }),
    query: z.object({
        requested_metrics: z.union([
            z.array(z.enum([
                'spike_count',
                'time_to_first_spike',
                'time_to_last_spike',
                'inv_time_to_first_spike',
                'doublet_ISI',
                'inv_first_ISI',
                'ISI_log_slope',
                'ISI_CV',
                'irregularity_index',
                'adaptation_index',
                'mean_frequency',
                'strict_burst_number',
                'strict_burst_mean_freq',
                'spikes_per_burst',
                'AP_height',
                'AP_amplitude',
                'AP1_amp',
                'APlast_amp',
                'AP_duration_half_width',
                'AHP_depth',
                'AHP_time_from_peak',
                'AP_peak_upstroke',
                'AP_peak_downstroke',
                'voltage_base',
                'voltage_after_stim',
                'ohmic_input_resistance_vb_ssse',
                'steady_state_voltage_stimend',
                'sag_amplitude',
                'decay_time_constant_after_stim',
                'depol_block_bool'
            ])),
            z.null()
        ]).optional(),
        protocols: z.union([
            z.array(z.enum([
                'spontaneous',
                'idrest',
                'idthreshold',
                'apwaveform',
                'iv',
                'step',
                'sponaps',
                'firepattern',
                'spontaneousnohold',
                'starthold',
                'startnohold',
                'delta',
                'sahp',
                'idhyperpol',
                'irdepol',
                'irhyperpol',
                'iddepol',
                'apthreshold',
                'hyperdepol',
                'negcheops',
                'poscheops',
                'spikerec',
                'sinespec',
                'genericstep'
            ])),
            z.null()
        ]).optional(),
        min_value: z.union([
            z.number(),
            z.null()
        ]).optional(),
        max_value: z.union([
            z.number(),
            z.null()
        ]).optional()
    }).optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zElectrophysiologyrecordingMetricsEndpointDeclaredElectrophysiologyrecordingMetricsTraceIdGetResponse = zElectrophysiologyMetricsOutput;

export const zValidateMeshFileDeclaredTestMeshFilePostData = z.object({
    body: zBodyValidateMeshFileDeclaredTestMeshFilePost,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zValidateMeshFileDeclaredTestMeshFilePostResponse = zMeshValidationResponse;

export const zNeuronMorphologyMetricsEndpointDeclaredNeuronMorphologyMetricsCellMorphologyIdGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        cell_morphology_id: z.string()
    }),
    query: z.object({
        requested_metrics: z.union([
            z.array(z.enum([
                'aspect_ratio',
                'circularity',
                'length_fraction_above_soma',
                'max_radial_distance',
                'number_of_neurites',
                'soma_radius',
                'soma_surface_area',
                'total_length',
                'total_height',
                'total_width',
                'total_depth',
                'total_area',
                'total_volume',
                'section_lengths',
                'segment_radii',
                'number_of_sections',
                'local_bifurcation_angles',
                'remote_bifurcation_angles',
                'section_path_distances',
                'section_radial_distances',
                'section_branch_orders',
                'section_strahler_orders'
            ])),
            z.null()
        ]).optional()
    }).optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zNeuronMorphologyMetricsEndpointDeclaredNeuronMorphologyMetricsCellMorphologyIdGetResponse = zMorphologyMetricsOutput;

export const zTestNeuronFileDeclaredTestNeuronFilePostData = z.object({
    body: zBodyTestNeuronFileDeclaredTestNeuronFilePost,
    path: z.never().optional(),
    query: z.object({
        single_point_soma: z.boolean().optional().default(false)
    }).optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

export const zMorphologyMetricsCalculationDeclaredRegisterMorphologyWithCalculatedMetricsPostData = z.object({
    body: zBodyMorphologyMetricsCalculationDeclaredRegisterMorphologyWithCalculatedMetricsPost,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Morphology Metrics Calculation Declared Register Morphology With Calculated Metrics Post
 *
 * Successful Response
 */
export const zMorphologyMetricsCalculationDeclaredRegisterMorphologyWithCalculatedMetricsPostResponse = z.record(z.unknown());

export const zParametricMultiValueEndpointDeclaredParametricMultiValuePostData = z.object({
    body: z.union([
        z.object({
            type: z.literal('IntRange')
        }).and(zIntRange),
        z.object({
            type: z.literal('PositiveIntRange')
        }).and(zPositiveIntRange),
        z.object({
            type: z.literal('NonNegativeIntRange')
        }).and(zNonNegativeIntRange),
        z.object({
            type: z.literal('FloatRange')
        }).and(zFloatRange),
        z.object({
            type: z.literal('PositiveFloatRange')
        }).and(zPositiveFloatRange),
        z.object({
            type: z.literal('NonNegativeFloatRange')
        }).and(zNonNegativeFloatRange)
    ]),
    path: z.never().optional(),
    query: z.object({
        ge: z.union([
            z.number(),
            z.number().int(),
            z.null()
        ]).optional(),
        gt: z.union([
            z.number(),
            z.number().int(),
            z.null()
        ]).optional(),
        le: z.union([
            z.number(),
            z.number().int(),
            z.null()
        ]).optional(),
        lt: z.union([
            z.number(),
            z.number().int(),
            z.null()
        ]).optional()
    }).optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Parametric Multi Value Endpoint Declared Parametric Multi Value Post
 *
 * Successful Response
 */
export const zParametricMultiValueEndpointDeclaredParametricMultiValuePostResponse = z.union([
    z.array(z.number()),
    z.array(z.number().int())
]);

export const zValidateNwbFileDeclaredValidateElectrophysiologyProtocolNwbFilePostData = z.object({
    body: zBodyValidateNwbFileDeclaredValidateElectrophysiologyProtocolNwbFilePost,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Successful Response
 */
export const zValidateNwbFileDeclaredValidateElectrophysiologyProtocolNwbFilePostResponse = zNwbValidationResponse;

export const zEndpointGeneratedCircuitSimulationScanConfigGenerateGridPostData = z.object({
    body: zCircuitSimulationScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Circuit Simulation Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedCircuitSimulationScanConfigGenerateGridPostResponse = z.string();

export const zEndpointGeneratedMeModelSimulationScanConfigGenerateGridPostData = z.object({
    body: zMeModelSimulationScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Me Model Simulation Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedMeModelSimulationScanConfigGenerateGridPostResponse = z.string();

export const zEndpointGeneratedMeModelWithSynapsesCircuitSimulationScanConfigGenerateGridPostData = z.object({
    body: zMeModelWithSynapsesCircuitSimulationScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Me Model With Synapses Circuit Simulation Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedMeModelWithSynapsesCircuitSimulationScanConfigGenerateGridPostResponse = z.string();

export const zEndpointGeneratedSimulationsGenerateGridSavePostData = z.object({
    body: zSimulationsForm,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Simulations Generate Grid Save Post
 *
 * Successful Response
 */
export const zEndpointGeneratedSimulationsGenerateGridSavePostResponse = z.string();

export const zEndpointGeneratedMorphologyMetricsScanConfigRunGridPostData = z.object({
    body: zMorphologyMetricsScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Morphology Metrics Scan Config Run Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedMorphologyMetricsScanConfigRunGridPostResponse = z.string();

export const zEndpointGeneratedContributeMorphologyScanConfigGenerateGridPostData = z.object({
    body: zContributeMorphologyScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Contribute Morphology Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedContributeMorphologyScanConfigGenerateGridPostResponse = z.string();

export const zEndpointGeneratedContributeSubjectScanConfigGenerateGridPostData = z.object({
    body: zContributeSubjectScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Contribute Subject Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedContributeSubjectScanConfigGenerateGridPostResponse = z.string();

export const zEndpointGeneratedIonChannelFittingScanConfigGenerateGridPostData = z.object({
    body: zIonChannelFittingScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Ion Channel Fitting Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedIonChannelFittingScanConfigGenerateGridPostResponse = z.string();

export const zEndpointGeneratedCircuitExtractionScanConfigGenerateGridPostData = z.object({
    body: zCircuitExtractionScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Circuit Extraction Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedCircuitExtractionScanConfigGenerateGridPostResponse = z.string();

export const zEndpointGeneratedSkeletonizationScanConfigGenerateGridPostData = z.object({
    body: zSkeletonizationScanConfig,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Endpoint Generated Skeletonization Scan Config Generate Grid Post
 *
 * Successful Response
 */
export const zEndpointGeneratedSkeletonizationScanConfigGenerateGridPostResponse = z.string();

export const zTaskLaunchEndpointDeclaredTaskLaunchPostData = z.object({
    body: zTaskLaunchCreate,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Task Launch Endpoint Declared Task Launch Post
 *
 * Successful Response
 */
export const zTaskLaunchEndpointDeclaredTaskLaunchPostResponse = z.union([
    z.string(),
    z.null()
]);

export const zEstimateEndpointDeclaredEstimatePostData = z.object({
    body: zTaskEstimateCreate,
    path: z.never().optional(),
    query: z.never().optional(),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});

/**
 * Response Estimate Endpoint Declared Estimate Post
 *
 * Successful Response
 */
export const zEstimateEndpointDeclaredEstimatePostResponse = z.record(z.unknown());

export const zTaskFailureEndpointDeclaredTaskFailurePostData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        execution_activity_id: z.string(),
        execution_activity_type: z.string()
    }),
    headers: z.object({
        'virtual-lab-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional(),
        'project-id': z.union([
            z.string().uuid(),
            z.null()
        ]).optional()
    }).optional()
});
