/**
 * Property Test: Tool Schema Compatibility
 *
 * Property 26: Tool Schema Compatibility
 * Validates: Requirements 18.1-18.10, 18.14, 18.16, 18.17, 18.18, 18.19, 18.20
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  getAvailableToolClasses,
  createToolInstance,
  registerToolClasses,
  type ToolConfig,
} from '../index';
import { z } from 'zod';

describe('Property 26: Tool Schema Compatibility', () => {
  let config: ToolConfig;

  beforeEach(async () => {
    config = {
      httpClient: {} as any,
      exaApiKey: 'test-exa-key',
      sanityUrl: 'https://api.sanity.io/test',
      entitycoreUrl: 'https://api.entitycore.test',
      entityFrontendUrl: 'https://entity.test',
      obiOneUrl: 'https://api.obione.test',
      thumbnailGenerationUrl: 'https://api.thumbnail.test',
      openaiApiKey: 'test-openai-key',
      vlabId: 'test-vlab-id',
      projectId: 'test-project-id',
      s3Client: {} as any,
      userId: 'test-user-id',
      bucketName: 'test-bucket',
      threadId: 'test-thread-id',
    };

    await registerToolClasses();
  });

  describe('Schema Validation', () => {
    it('should have valid Zod schemas for all tools', async () => {
      const toolClasses = await getAvailableToolClasses(config);
      const productionTools = toolClasses.filter(
        (cls) => !cls.toolName.startsWith('get_') && !cls.toolName.includes('calculator')
      );

      expect(productionTools.length).toBeGreaterThan(0);

      for (const ToolClass of productionTools) {
        try {
          const instance = await createToolInstance(ToolClass, config);
          expect(instance.inputSchema).toBeDefined();
          expect(instance.inputSchema instanceof z.ZodType).toBe(true);
        } catch (error) {
          console.warn(`Could not instantiate ${ToolClass.toolName}`);
        }
      }
    });

    it('should validate BrainRegionGetAll inputs', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');
      const instance = await createToolInstance(BrainRegionGetAllTool, config);

      const validInput = { page: 1, page_size: 5 };
      const result = instance.inputSchema.safeParse(validInput);
      expect(result.success).toBe(true);

      const invalidInput = { page: -1, page_size: 5 };
      const invalidResult = instance.inputSchema.safeParse(invalidInput);
      expect(invalidResult.success).toBe(false);
    });

    it('should convert tools to Vercel AI SDK format', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');
      const instance = await createToolInstance(BrainRegionGetAllTool, config);
      const vercelTool = instance.toVercelTool();

      expect(vercelTool).toBeDefined();
      expect(vercelTool.description).toBeDefined();
      expect(typeof vercelTool.execute).toBe('function');
    });
  });

  describe('Tool Metadata', () => {
    it('should have complete metadata for all tools', async () => {
      const toolClasses = await getAvailableToolClasses(config);

      toolClasses.forEach((ToolClass) => {
        expect(ToolClass.toolName).toBeDefined();
        expect(ToolClass.toolDescription).toBeDefined();
        expect(ToolClass.toolName.length).toBeGreaterThan(0);
        expect(ToolClass.toolDescription.length).toBeGreaterThan(0);
      });
    });

    it('should follow naming conventions', async () => {
      const toolClasses = await getAvailableToolClasses(config);

      toolClasses.forEach((ToolClass) => {
        const toolName = ToolClass.toolName;
        expect(toolName).toMatch(/^[a-z0-9-_]+$/);

        if (toolName.includes('entitycore')) {
          expect(toolName).toMatch(/^entitycore-/);
        }
      });
    });
  });

  describe('Autogenerated Schemas', () => {
    it('should use autogenerated schemas for EntityCore tools', async () => {
      const toolClasses = await getAvailableToolClasses(config);
      const entitycoreTools = toolClasses.filter((cls) =>
        cls.toolName.startsWith('entitycore-')
      );

      expect(entitycoreTools.length).toBeGreaterThan(0);
      const toolNames = entitycoreTools.map((cls) => cls.toolName);
      expect(toolNames).toContain('entitycore-brainregion-getall');
    });

    it('should use autogenerated schemas for OBIOne tools', async () => {
      const toolClasses = await getAvailableToolClasses(config);
      const obioneTools = toolClasses.filter((cls) => cls.toolName.startsWith('obione-'));

      expect(obioneTools.length).toBeGreaterThan(0);
      const toolNames = obioneTools.map((cls) => cls.toolName);
      expect(toolNames).toContain('obione-circuitmetrics-getone');
    });
  });
});
