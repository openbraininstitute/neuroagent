/**
 * Property Test: Tool Output Consistency
 *
 * **Property 27: Tool Output Consistency**
 * **Validates: Requirements 18.1-18.10, 18.14, 18.16, 18.17, 18.18, 18.19, 18.20**
 *
 * Tests that translated TypeScript tools produce equivalent outputs to their Python versions.
 *
 * This property test verifies that:
 * 1. Tool outputs have the same structure as Python versions
 * 2. Tool outputs contain the same data fields
 * 3. Tool outputs follow the same format conventions
 * 4. Tool error handling produces equivalent error messages
 *
 * Note: This test focuses on verifying that the TypeScript tools use the same
 * autogenerated schemas and follow the same patterns as Python tools, ensuring
 * output consistency through schema validation rather than mocking exact responses.
 */

import { describe, it, expect } from 'vitest';

describe('Property 27: Tool Output Consistency', () => {
  describe('EntityCore Tool Output Schema Consistency', () => {
    it('should use autogenerated Zod schemas matching Python Pydantic models', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');

      // Verify tool uses the autogenerated schema
      expect(BrainRegionGetAllTool).toBeDefined();
      expect(BrainRegionGetAllTool.toolName).toBe('entitycore-brainregion-getall');

      // Verify tool has input schema
      const instance = new BrainRegionGetAllTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });
      expect(instance.inputSchema).toBeDefined();
    });

    it('should use autogenerated schemas for CellMorphology tools', async () => {
      const { CellMorphologyGetOneTool } = await import(
        '../entitycore/cell-morphology-getone'
      );

      // Verify tool uses the autogenerated schema
      expect(CellMorphologyGetOneTool).toBeDefined();
      expect(CellMorphologyGetOneTool.toolName).toBe('entitycore-cellmorphology-getone');

      // Verify tool has input schema
      const instance = new CellMorphologyGetOneTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });
      expect(instance.inputSchema).toBeDefined();
    });

    it('should use autogenerated schemas for all EntityCore tools', async () => {
      // Import all EntityCore tool modules
      const modules = [
        '../entitycore/brain-region-getall',
        '../entitycore/brain-region-getone',
        '../entitycore/cell-morphology-getall',
        '../entitycore/cell-morphology-getone',
        '../entitycore/brain-atlas-getall',
        '../entitycore/brain-atlas-getone',
      ];

      for (const modulePath of modules) {
        const module = await import(modulePath);
        const toolClass = Object.values(module)[0] as any;

        // Verify tool class exists and has required properties
        expect(toolClass).toBeDefined();
        expect(toolClass.toolName).toBeDefined();
        expect(toolClass.toolDescription).toBeDefined();
      }
    });
  });

  describe('OBIOne Tool Output Schema Consistency', () => {
    it('should use autogenerated Zod schemas matching Python Pydantic models', async () => {
      const { CircuitMetricGetOneTool } = await import('../obione/circuit-metric-getone');

      // Verify tool uses the autogenerated schema
      expect(CircuitMetricGetOneTool).toBeDefined();
      expect(CircuitMetricGetOneTool.toolName).toBe('obione-circuitmetrics-getone');

      // Verify tool has input schema
      const instance = new CircuitMetricGetOneTool({
        httpClient: {} as any,
        obiOneUrl: 'https://test.com',
      });
      expect(instance.inputSchema).toBeDefined();
    });

    it('should use autogenerated schemas for all OBIOne tools', async () => {
      // Import all OBIOne tool modules
      const modules = [
        '../obione/circuit-metric-getone',
        '../obione/circuit-nodesets-getone',
        '../obione/circuit-population-getone',
        '../obione/ephys-metrics-getone',
        '../obione/morphometrics-getone',
      ];

      for (const modulePath of modules) {
        const module = await import(modulePath);
        const toolClass = Object.values(module).find(
          (val) => typeof val === 'function' && val.name.endsWith('Tool')
        ) as any;

        // Verify tool class exists and has required properties
        expect(toolClass).toBeDefined();
        expect(toolClass.toolName).toBeDefined();
        expect(toolClass.toolDescription).toBeDefined();
      }
    });
  });

  describe('Standalone Tool Output Structure Consistency', () => {
    it('should define consistent output structure for LiteratureSearch', async () => {
      const { LiteratureSearchTool } = await import('../standalone/literature-search');

      // Verify tool exists and has metadata
      expect(LiteratureSearchTool).toBeDefined();
      expect(LiteratureSearchTool.toolName).toBe('literature-search-tool');
      expect(LiteratureSearchTool.toolDescription).toBeDefined();

      // Verify tool has input schema
      const mockHttpClient = {} as any; // Mock httpClient for test
      const instance = new LiteratureSearchTool({
        exaApiKey: 'test',
        httpClient: mockHttpClient,
      });
      expect(instance.inputSchema).toBeDefined();
    });

    it('should define consistent output structure for WebSearch', async () => {
      const { WebSearchTool } = await import('../standalone/web-search');

      // Verify tool exists and has metadata
      expect(WebSearchTool).toBeDefined();
      expect(WebSearchTool.toolName).toBe('web-search-tool');
      expect(WebSearchTool.toolDescription).toBeDefined();

      // Verify tool has input schema
      const mockHttpClient = {} as any; // Mock httpClient for test
      const instance = new WebSearchTool({
        exaApiKey: 'test',
        httpClient: mockHttpClient,
      });
      expect(instance.inputSchema).toBeDefined();
    });

    it('should define consistent output structure for CircuitPopulationAnalysis', async () => {
      const { CircuitPopulationAnalysisTool } = await import(
        '../standalone/circuit-population-analysis'
      );

      // Verify tool exists and has metadata
      expect(CircuitPopulationAnalysisTool).toBeDefined();
      expect(CircuitPopulationAnalysisTool.toolName).toBe(
        'circuit-population-data-analysis'
      );
      expect(CircuitPopulationAnalysisTool.toolDescription).toBeDefined();
    });

    it('should define consistent output structure for OBIExpert', async () => {
      const { OBIExpertTool } = await import('../standalone/obi-expert');

      // Verify tool exists and has metadata
      expect(OBIExpertTool).toBeDefined();
      expect(OBIExpertTool.toolName).toBe('obi-expert');
      expect(OBIExpertTool.toolDescription).toBeDefined();
    });

    it('should define consistent output structure for ReadPaper', async () => {
      const { ReadPaperTool } = await import('../standalone/read-paper');

      // Verify tool exists and has metadata
      expect(ReadPaperTool).toBeDefined();
      expect(ReadPaperTool.toolName).toBe('read-paper');
      expect(ReadPaperTool.toolDescription).toBeDefined();
    });
  });

  describe('Schema Validation Consistency', () => {
    it('should validate inputs using Zod schemas like Python Pydantic', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');

      const instance = new BrainRegionGetAllTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });

      // Verify input schema exists and can validate
      expect(instance.inputSchema).toBeDefined();

      // Test valid input passes validation
      const validInput = { page: 1, page_size: 5 };
      const parsed = instance.inputSchema.parse(validInput);

      // Verify core fields are present (may have defaults added)
      expect(parsed.page).toBe(1);
      expect(parsed.page_size).toBe(5);

      // Test invalid input fails validation
      const invalidInput = { page: 1, page_size: 100 }; // Exceeds max
      expect(() => instance.inputSchema.parse(invalidInput)).toThrow();
    });

    it('should enforce same constraints as Python tools', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');

      const instance = new BrainRegionGetAllTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });

      // Test page_size constraints (matching Python Field(ge=1, le=10))
      expect(() => instance.inputSchema.parse({ page: 1, page_size: 0 })).toThrow();
      expect(() => instance.inputSchema.parse({ page: 1, page_size: 11 })).toThrow();
      expect(() => instance.inputSchema.parse({ page: 1, page_size: 5 })).not.toThrow();
    });
  });

  describe('Error Handling Consistency', () => {
    it('should throw errors for invalid inputs like Python tools', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');

      const instance = new BrainRegionGetAllTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });

      // Test that validation errors are thrown (matching Python Pydantic behavior)
      expect(() =>
        instance.inputSchema.parse({
          page: 'invalid', // Should be number
          page_size: 5,
        })
      ).toThrow();
    });

    it('should validate required fields like Python tools', async () => {
      const { BrainRegionGetOneTool } = await import('../entitycore/brain-region-getone');

      const instance = new BrainRegionGetOneTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });

      // Test that missing required fields throw errors
      expect(() => instance.inputSchema.parse({})).toThrow();

      // Test with required field (brainregion_id must be a valid UUID)
      const validUuid = 'e3e70682-c209-4cac-a29f-6fbed82c07cd';
      expect(() => instance.inputSchema.parse({ brainregion_id: validUuid })).not.toThrow();
    });
  });

  describe('Type Safety Consistency', () => {
    it('should enforce TypeScript types matching Python type hints', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');

      // Verify tool class has static type properties
      expect(typeof BrainRegionGetAllTool.toolName).toBe('string');
      expect(typeof BrainRegionGetAllTool.toolDescription).toBe('string');

      // Verify instance has typed methods
      const instance = new BrainRegionGetAllTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });

      expect(typeof instance.execute).toBe('function');
      expect(typeof instance.toVercelTool).toBe('function');
    });

    it('should use Zod type inference like Python Pydantic', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');

      const instance = new BrainRegionGetAllTool({
        httpClient: {} as any,
        entitycoreUrl: 'https://test.com',
        entityFrontendUrl: 'https://test.com',
      });

      // Verify schema can infer TypeScript types
      type InputType = ReturnType<typeof instance.inputSchema.parse>;

      // This should compile without errors, proving type inference works
      const input: InputType = {
        page: 1,
        page_size: 5,
        hierarchy_id: 'e3e70682-c209-4cac-a29f-6fbed82c07cd',
        order_by: [],
      };
      expect(input).toBeDefined();
    });
  });

  describe('Metadata Consistency', () => {
    it('should preserve tool metadata from Python versions', async () => {
      const { BrainRegionGetAllTool } = await import('../entitycore/brain-region-getall');

      // Verify metadata matches Python tool
      expect(BrainRegionGetAllTool.toolName).toBe('entitycore-brainregion-getall');
      expect(BrainRegionGetAllTool.toolDescription).toContain('brain region');
      expect(BrainRegionGetAllTool.toolUtterances).toBeDefined();
      expect(Array.isArray(BrainRegionGetAllTool.toolUtterances)).toBe(true);
    });

    it('should preserve metadata for all translated tools', async () => {
      const toolModules = [
        { path: '../entitycore/brain-region-getall', name: 'BrainRegionGetAllTool' },
        { path: '../entitycore/cell-morphology-getall', name: 'CellMorphologyGetAllTool' },
        { path: '../obione/circuit-metric-getone', name: 'CircuitMetricGetOneTool' },
        { path: '../standalone/literature-search', name: 'LiteratureSearchTool' },
        { path: '../standalone/web-search', name: 'WebSearchTool' },
      ];

      for (const { path, name } of toolModules) {
        const module = await import(path);
        const ToolClass = module[name];

        // Verify all tools have complete metadata
        expect(ToolClass.toolName).toBeDefined();
        expect(ToolClass.toolName.length).toBeGreaterThan(0);
        expect(ToolClass.toolDescription).toBeDefined();
        expect(ToolClass.toolDescription.length).toBeGreaterThan(0);
      }
    });
  });
});
