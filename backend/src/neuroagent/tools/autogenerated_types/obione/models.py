# generated by fastapi-codegen:
#   filename:  openapi.json
#   timestamp: 2025-05-19T12:31:02+00:00

from __future__ import annotations

from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel, confloat, constr


class Circuit(BaseModel):
    type: Literal['Circuit'] = Field(..., title='Type')
    name: str = Field(..., title='Name')
    path: str = Field(..., title='Path')


class ClusteredGroupedMorphologyLocations(BaseModel):
    type: Literal['ClusteredGroupedMorphologyLocations'] = Field(..., title='Type')
    random_seed: Optional[Union[int, List[int]]] = Field(
        0,
        description='Seed for the random generation of locations',
        title='Random Seed',
    )
    number_of_locations: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of locations to generate on morphology',
        title='Number Of Locations',
    )
    section_types: Optional[Union[List[int], List[List[int]]]] = Field(
        None,
        description='Types of sections to generate locations on. 2: axon, 3: basal, 4: apical',
        title='Section Types',
    )
    n_groups: Optional[Union[int, List[int]]] = Field(
        1, description='Number of groups of locations to generate', title='N Groups'
    )
    n_clusters: Union[int, List[int]] = Field(
        ..., description='Number of location clusters to generate', title='N Clusters'
    )
    cluster_max_distance: Union[float, List[float]] = Field(
        ...,
        description='Maximum distance in um of generated locations from the center of their cluster',
        title='Cluster Max Distance',
    )


class ClusteredMorphologyLocations(BaseModel):
    type: Literal['ClusteredMorphologyLocations'] = Field(..., title='Type')
    random_seed: Optional[Union[int, List[int]]] = Field(
        0,
        description='Seed for the random generation of locations',
        title='Random Seed',
    )
    number_of_locations: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of locations to generate on morphology',
        title='Number Of Locations',
    )
    section_types: Optional[Union[List[int], List[List[int]]]] = Field(
        None,
        description='Types of sections to generate locations on. 2: axon, 3: basal, 4: apical',
        title='Section Types',
    )
    n_clusters: Union[int, List[int]] = Field(
        ..., description='Number of location clusters to generate', title='N Clusters'
    )
    cluster_max_distance: Union[float, List[float]] = Field(
        ...,
        description='Maximum distance in um of generated locations from the center of their cluster',
        title='Cluster Max Distance',
    )


class ClusteredPathDistanceMorphologyLocations(BaseModel):
    type: Literal['ClusteredPathDistanceMorphologyLocations'] = Field(..., title='Type')
    random_seed: Optional[Union[int, List[int]]] = Field(
        0,
        description='Seed for the random generation of locations',
        title='Random Seed',
    )
    number_of_locations: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of locations to generate on morphology',
        title='Number Of Locations',
    )
    section_types: Optional[Union[List[int], List[List[int]]]] = Field(
        None,
        description='Types of sections to generate locations on. 2: axon, 3: basal, 4: apical',
        title='Section Types',
    )
    n_clusters: Union[int, List[int]] = Field(
        ..., description='Number of location clusters to generate', title='N Clusters'
    )
    cluster_max_distance: Union[float, List[float]] = Field(
        ...,
        description='Maximum distance in um of generated locations from the center of their cluster',
        title='Cluster Max Distance',
    )
    path_dist_mean: Union[float, List[float]] = Field(
        ...,
        description='Mean of a Gaussian, defined on soma path distance in um. Used to determine locations.',
        title='Path Dist Mean',
    )
    path_dist_sd: Union[float, List[float]] = Field(
        ...,
        description='SD of a Gaussian, defined on soma path distance in um. Used to determine locations.',
        title='Path Dist Sd',
    )
    n_groups_per_cluster: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of conceptual groups per location cluster to generate',
        title='N Groups Per Cluster',
    )


class NodeSet(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class NodeSet1Item(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class NodeSet1(RootModel[List[NodeSet1Item]]):
    root: List[NodeSet1Item]


class CombinedNeuronSet(BaseModel):
    type: Literal['CombinedNeuronSet'] = Field(..., title='Type')
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    random_sample: Optional[Union[int, float, List[Optional[Union[int, float]]]]] = (
        Field(None, title='Random Sample')
    )
    random_seed: Optional[Union[int, List[int]]] = Field(0, title='Random Seed')
    node_sets: Union[List[NodeSet], List[NodeSet1]] = Field(..., title='Node Sets')


class NeuronId(RootModel[List[int]]):
    root: List[int]


class IDNeuronSet(BaseModel):
    type: Literal['IDNeuronSet'] = Field(..., title='Type')
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    random_sample: Optional[Union[int, float, List[Optional[Union[int, float]]]]] = (
        Field(None, title='Random Sample')
    )
    random_seed: Optional[Union[int, List[int]]] = Field(0, title='Random Seed')
    neuron_ids: Union[List[int], List[NeuronId]] = Field(..., title='Neuron Ids')


class IDSynapseSet(BaseModel):
    type: Literal['IDSynapseSet'] = Field(..., title='Type')
    circuit: Circuit
    synapse_ids: Union[List[int], List[List[int]]] = Field(..., title='Synapse Ids')


class MorphologyLocationsBlock(BaseModel):
    type: Literal['MorphologyLocationsBlock'] = Field(..., title='Type')
    random_seed: Optional[Union[int, List[int]]] = Field(
        0,
        description='Seed for the random generation of locations',
        title='Random Seed',
    )
    number_of_locations: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of locations to generate on morphology',
        title='Number Of Locations',
    )
    section_types: Optional[Union[List[int], List[List[int]]]] = Field(
        None,
        description='Types of sections to generate locations on. 2: axon, 3: basal, 4: apical',
        title='Section Types',
    )


class MorphologyMetricsOutput(BaseModel):
    aspect_ratio: float = Field(
        ...,
        description='Calculates the min/max ratio of the principal direction extents                 along the plane.',
        title='aspect_ratio',
    )
    circularity: float = Field(
        ...,
        description='Calculates the circularity of the morphology points along the plane.',
        title='circularity',
    )
    length_fraction_above_soma: float = Field(
        ...,
        description='Returns the length fraction of the segments that have their midpoints                             higher than the soma.',
        title='length_fraction_above_soma',
    )
    max_radial_distance: float = Field(
        ...,
        description='Get the maximum radial distances of the termination sections.',
        title='max_radial_distance',
    )
    number_of_neurites: int = Field(
        ..., description='Number of neurites in a morph.', title='number_of_neurites'
    )
    soma_radius: float = Field(
        ...,
        description='The radius of the soma in micrometers.',
        title='soma_radius [μm]',
    )
    soma_surface_area: float = Field(
        ...,
        description='The surface area of the soma in square micrometers.',
        title='soma_surface_area [μm^2]',
    )


class NamedPath(BaseModel):
    type: Literal['NamedPath'] = Field(..., title='Type')
    name: str = Field(..., title='Name')
    path: str = Field(..., title='Path')


class PathDistanceMorphologyLocations(BaseModel):
    type: Literal['PathDistanceMorphologyLocations'] = Field(..., title='Type')
    random_seed: Optional[Union[int, List[int]]] = Field(
        0,
        description='Seed for the random generation of locations',
        title='Random Seed',
    )
    number_of_locations: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of locations to generate on morphology',
        title='Number Of Locations',
    )
    section_types: Optional[Union[List[int], List[List[int]]]] = Field(
        None,
        description='Types of sections to generate locations on. 2: axon, 3: basal, 4: apical',
        title='Section Types',
    )
    path_dist_mean: Union[float, List[float]] = Field(
        ...,
        description='Mean of a Gaussian, defined on soma path distance in um. Used to determine locations.',
        title='Path Dist Mean',
    )
    path_dist_tolerance: Union[float, List[float]] = Field(
        ...,
        description='Amount of deviation in um from mean path distance that is tolerated. Must be > 1.0',
        title='Path Dist Tolerance',
    )


class NodeSetItem(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class PredefinedNeuronSet(BaseModel):
    type: Literal['PredefinedNeuronSet'] = Field(..., title='Type')
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    random_sample: Optional[Union[int, float, List[Optional[Union[int, float]]]]] = (
        Field(None, title='Random Sample')
    )
    random_seed: Optional[Union[int, List[int]]] = Field(0, title='Random Seed')
    node_set: Union[constr(min_length=1), List[NodeSetItem]] = Field(
        ..., title='Node Set'
    )


class PropertyNeuronSet(BaseModel):
    type: Literal['PropertyNeuronSet'] = Field(..., title='Type')
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    random_sample: Optional[Union[int, float, List[Optional[Union[int, float]]]]] = (
        Field(None, title='Random Sample')
    )
    random_seed: Optional[Union[int, List[int]]] = Field(0, title='Random Seed')
    property_specs: Union[Dict[str, Any], List[Dict[str, Any]]] = Field(
        ..., title='Property Specs'
    )
    node_sets: Optional[
        Union[List[constr(min_length=1)], List[List[constr(min_length=1)]]]
    ] = Field([], title='Node Sets')


class RandomGroupedMorphologyLocations(BaseModel):
    type: Literal['RandomGroupedMorphologyLocations'] = Field(..., title='Type')
    random_seed: Optional[Union[int, List[int]]] = Field(
        0,
        description='Seed for the random generation of locations',
        title='Random Seed',
    )
    number_of_locations: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of locations to generate on morphology',
        title='Number Of Locations',
    )
    section_types: Optional[Union[List[int], List[List[int]]]] = Field(
        None,
        description='Types of sections to generate locations on. 2: axon, 3: basal, 4: apical',
        title='Section Types',
    )
    n_groups: Optional[Union[int, List[int]]] = Field(
        1, description='Number of groups of locations to generate', title='N Groups'
    )


class RandomMorphologyLocations(BaseModel):
    type: Literal['RandomMorphologyLocations'] = Field(..., title='Type')
    random_seed: Optional[Union[int, List[int]]] = Field(
        0,
        description='Seed for the random generation of locations',
        title='Random Seed',
    )
    number_of_locations: Optional[Union[int, List[int]]] = Field(
        1,
        description='Number of locations to generate on morphology',
        title='Number Of Locations',
    )
    section_types: Optional[Union[List[int], List[List[int]]]] = Field(
        None,
        description='Types of sections to generate locations on. 2: axon, 3: basal, 4: apical',
        title='Section Types',
    )


class ReconstructionMorphologyFromID(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id_str: str = Field(
        ..., description='ID of the entity in string format.', title='Id Str'
    )


class RegularTimestamps(BaseModel):
    type: Literal['RegularTimestamps'] = Field(..., title='Type')
    start_time: Union[float, List[float]] = Field(..., title='Start Time')
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    number_of_repetitions: Union[int, List[int]] = Field(
        ..., title='Number Of Repetitions'
    )
    interval: Union[float, List[float]] = Field(..., title='Interval')


class RelativeConstantCurrentClampSomaticStimulus(BaseModel):
    type: Literal['RelativeConstantCurrentClampSomaticStimulus'] = Field(
        ..., title='Type'
    )
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    percentage_of_threshold_current: Optional[Union[float, List[float]]] = Field(
        10,
        description='The percentage of a cell’s threshold current to inject when the stimulus                     activates.',
        title='Percentage Of Threshold Current',
    )


class RelativeLinearCurrentClampSomaticStimulus(BaseModel):
    type: Literal['RelativeLinearCurrentClampSomaticStimulus'] = Field(
        ..., title='Type'
    )
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    percentage_of_threshold_current_start: Optional[Union[float, List[float]]] = Field(
        10,
        description="The percentage of a cell's threshold current to inject when the stimulus activates.",
        title='Percentage Of Threshold Current Start',
    )
    percentage_of_threshold_current_end: Optional[Union[float, List[float]]] = Field(
        100,
        description="If given, the percentage of a cell's threshold current is interpolated such that the percentage reaches this value when the stimulus concludes.",
        title='Percentage Of Threshold Current End',
    )


class SinusoidalCurrentClampSomaticStimulus(BaseModel):
    type: Literal['SinusoidalCurrentClampSomaticStimulus'] = Field(..., title='Type')
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    peak_amplitude: Optional[Union[float, List[float]]] = Field(
        0.1,
        description='The peak amplitude of the sinusoid. Given in nA.',
        title='Peak Amplitude',
    )
    frequency: Optional[Union[float, List[float]]] = Field(
        1, description='The frequency of the waveform. Given in Hz.', title='Frequency'
    )
    dt: Optional[Union[float, List[float]]] = Field(
        0.025,
        description='Timestep of generated signal in ms. Default is 0.025 ms.',
        title='Dt',
    )


class SomaVoltageRecording(BaseModel):
    type: Literal['SomaVoltageRecording'] = Field(..., title='Type')
    start_time: Union[confloat(ge=0.0), List[confloat(ge=0.0)]] = Field(
        ..., description='Recording start time in ms.', title='Start Time'
    )
    end_time: Union[confloat(ge=0.0), List[confloat(ge=0.0)]] = Field(
        ..., description='Recording end time in ms.', title='End Time'
    )
    dt: Optional[Union[confloat(ge=0.0), List[confloat(ge=0.0)]]] = Field(
        0.1, description='Interval between recording time steps in ms.', title='Dt'
    )
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(..., description='Neuron set to record from.', title='Neuron Set')


class SubthresholdCurrentClampSomaticStimulus(BaseModel):
    type: Literal['SubthresholdCurrentClampSomaticStimulus'] = Field(..., title='Type')
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    percentage_below_threshold: Optional[Union[float, List[float]]] = Field(
        0.1,
        description="A percentage adjusted from 100 of a cell's threshold current. \\\n                        E.g. 20 will apply 80% of the threshold current. Using a negative \\\n                            value will give more than 100. E.g. -20 will inject 120% of the \\\n                                threshold current.",
        title='Percentage Below Threshold',
    )


class SynchronousSingleSpikeStimulus(BaseModel):
    type: Literal['SynchronousSingleSpikeStimulus'] = Field(..., title='Type')
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    spike_probability: Union[float, List[float]] = Field(..., title='Spike Probability')


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class XYZExtracellularLocationSet(BaseModel):
    type: Literal['XYZExtracellularLocationSet'] = Field(..., title='Type')
    xyz_locations: Optional[Union[List[List], List[List[List]]]] = Field(
        [[0, 0, 0]], title='Xyz Locations'
    )


class ObiOneScientificBasicConnectivityPlotsBasicConnectivityPlotsBasicConnectivityPlotsInitialize(
    BaseModel
):
    type: Literal['BasicConnectivityPlots.Initialize'] = Field(..., title='Type')
    matrix_path: Union[NamedPath, List[NamedPath]] = Field(..., title='Matrix Path')
    plot_formats: Optional[List[str]] = Field(
        ['png', 'pdf', 'svg'], title='Plot Formats'
    )
    plot_types: Optional[List[str]] = Field(
        ['nodes', 'connectivity_global', 'connectivity_pathway'], title='Plot Types'
    )
    dpi: Optional[int] = Field(300, title='Dpi')


class ObiOneScientificCircuitExtractionCircuitExtractionCircuitExtractionsInitialize(
    BaseModel
):
    type: Literal['CircuitExtractions.Initialize'] = Field(..., title='Type')
    circuit_path: Union[NamedPath, List[NamedPath]] = Field(..., title='Circuit Path')


class ObiOneScientificConnectivityMatrixExtractionConnectivityMatrixExtractionConnectivityMatrixExtractionsInitialize(
    BaseModel
):
    type: Literal['ConnectivityMatrixExtractions.Initialize'] = Field(..., title='Type')
    circuit_path: Union[NamedPath, List[NamedPath]] = Field(..., title='Circuit Path')
    edge_population: Optional[Union[str, List[Optional[str]]]] = Field(
        None, title='Edge Population'
    )
    node_attributes: Optional[Union[List[str], List[Optional[List[str]]]]] = Field(
        None, title='Node Attributes'
    )


class ObiOneScientificFolderCompressionFolderCompressionFolderCompressionsInitialize(
    BaseModel
):
    type: Literal['FolderCompressions.Initialize'] = Field(..., title='Type')
    folder_path: Union[NamedPath, List[NamedPath]] = Field(..., title='Folder Path')
    file_format: Optional[Union[str, List[Optional[str]]]] = Field(
        'gz', title='File Format'
    )
    file_name: Optional[Union[str, List[Optional[str]]]] = Field(
        'compressed', title='File Name'
    )


class ObiOneScientificMorphologyContainerizationMorphologyContainerizationMorphologyContainerizationsFormInitialize(
    BaseModel
):
    type: Literal['MorphologyContainerizationsForm.Initialize'] = Field(
        ..., title='Type'
    )
    circuit_path: Union[NamedPath, List[NamedPath]] = Field(..., title='Circuit Path')
    hoc_template_old: str = Field(..., title='Hoc Template Old')
    hoc_template_new: str = Field(..., title='Hoc Template New')


class ObiOneScientificMorphologyLocationsMorphologyLocationFormMorphologyLocationsFormInitialize(
    BaseModel
):
    type: Literal['MorphologyLocationsForm.Initialize'] = Field(..., title='Type')
    morphology: Union[
        ReconstructionMorphologyFromID,
        List[ReconstructionMorphologyFromID],
        Path,
        List[Path],
    ] = Field(
        ...,
        description='The morphology skeleton to place locations on',
        title='Morphology',
    )


class ObiOneScientificMorphologyMetricsMorphologyMetricsMorphologyMetricsFormInitialize(
    BaseModel
):
    type: Literal['MorphologyMetricsForm.Initialize'] = Field(..., title='Type')
    morphology: Union[
        ReconstructionMorphologyFromID, List[ReconstructionMorphologyFromID]
    ] = Field(..., description='3. Morphology description', title='Morphology')


class SpikeLocation(Enum):
    AIS = 'AIS'
    soma = 'soma'


class SpikeLocationEnum(Enum):
    AIS = 'AIS'
    soma = 'soma'


class ObiOneScientificSimulationSimulationsSimulationsFormInitialize(BaseModel):
    type: Literal['SimulationsForm.Initialize'] = Field(..., title='Type')
    circuit: Union[List[Circuit], Circuit] = Field(..., title='Circuit')
    simulation_length: Optional[Union[List[float], float]] = Field(
        100, title='Simulation Length'
    )
    node_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(..., title='Node Set')
    random_seed: Optional[Union[List[int], int]] = Field(1, title='Random Seed')
    extracellular_calcium_concentration: Optional[Union[List[float], float]] = Field(
        1.1, title='Extracellular Calcium Concentration'
    )
    v_init: Optional[Union[List[float], float]] = Field(-80, title='V Init')
    spike_location: Optional[Union[SpikeLocation, List[SpikeLocationEnum]]] = Field(
        'soma', title='Spike Location'
    )
    sonata_version: Optional[Union[List[int], int]] = Field(1, title='Sonata Version')
    target_simulator: Optional[Union[List[str], str]] = Field(
        'CORENEURON', title='Target Simulator'
    )
    timestep: Optional[Union[List[float], float]] = Field(0.025, title='Timestep')


class ObiOneScientificTestFormsTestFormSingleBlockSingleBlockEntityTestFormInitialize(
    BaseModel
):
    type: Literal['SingleBlockEntityTestForm.Initialize'] = Field(..., title='Type')
    morphology: Union[
        ReconstructionMorphologyFromID, List[ReconstructionMorphologyFromID]
    ] = Field(..., title='Morphology')


class ObiOneScientificTestFormsTestFormSingleBlockSingleBlockGenerateTestFormInitialize(
    BaseModel
):
    type: Literal['SingleBlockGenerateTestForm.Initialize'] = Field(..., title='Type')
    morphology_path: Union[NamedPath, List[NamedPath]] = Field(
        ..., title='Morphology Path'
    )


class FieldDatamodelCodeGeneratorRootSpecialGetResponse(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class HealthGetResponse(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class VersionGetResponse(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class VirtualLabId(RootModel[Optional[UUID]]):
    root: Optional[UUID] = Field(..., title='Virtual Lab Id')


class ProjectId(RootModel[Optional[UUID]]):
    root: Optional[UUID] = Field(..., title='Project Id')


class BasicConnectivityPlots(BaseModel):
    type: Literal['BasicConnectivityPlots'] = Field(..., title='Type')
    initialize: ObiOneScientificBasicConnectivityPlotsBasicConnectivityPlotsBasicConnectivityPlotsInitialize


class CircuitExtractions(BaseModel):
    type: Literal['CircuitExtractions'] = Field(..., title='Type')
    initialize: (
        ObiOneScientificCircuitExtractionCircuitExtractionCircuitExtractionsInitialize
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(..., title='Neuron Set')


class ConnectivityMatrixExtractions(BaseModel):
    type: Literal['ConnectivityMatrixExtractions'] = Field(..., title='Type')
    initialize: ObiOneScientificConnectivityMatrixExtractionConnectivityMatrixExtractionConnectivityMatrixExtractionsInitialize


class ConstantCurrentClampSomaticStimulus(BaseModel):
    type: Literal['ConstantCurrentClampSomaticStimulus'] = Field(..., title='Type')
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    amplitude: Optional[Union[float, List[float]]] = Field(
        0.1, description='The injected current. Given in nA.', title='Amplitude'
    )


class FolderCompressions(BaseModel):
    type: Literal['FolderCompressions'] = Field(..., title='Type')
    initialize: (
        ObiOneScientificFolderCompressionFolderCompressionFolderCompressionsInitialize
    )


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title='Detail')


class HyperpolarizingCurrentClampSomaticStimulus(BaseModel):
    type: Literal['HyperpolarizingCurrentClampSomaticStimulus'] = Field(
        ..., title='Type'
    )
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )


class LinearCurrentClampSomaticStimulus(BaseModel):
    type: Literal['LinearCurrentClampSomaticStimulus'] = Field(..., title='Type')
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    amplitude_start: Optional[Union[float, List[float]]] = Field(
        0.1,
        description='The amount of current initially injected when the stimulus activates. Given in nA.',
        title='Amplitude Start',
    )
    amplitude_end: Optional[Union[float, List[float]]] = Field(
        0.2,
        description='If given, current is interpolated such that current reaches this value when the stimulus concludes. Otherwise, current stays at amp_start. Given in nA',
        title='Amplitude End',
    )


class MorphologyContainerizationsForm(BaseModel):
    type: Literal['MorphologyContainerizationsForm'] = Field(..., title='Type')
    initialize: ObiOneScientificMorphologyContainerizationMorphologyContainerizationMorphologyContainerizationsFormInitialize


class MorphologyLocationsForm(BaseModel):
    type: Literal['MorphologyLocationsForm'] = Field(..., title='Type')
    initialize: ObiOneScientificMorphologyLocationsMorphologyLocationFormMorphologyLocationsFormInitialize
    morph_locations: Union[
        MorphologyLocationsBlock,
        RandomGroupedMorphologyLocations,
        RandomMorphologyLocations,
        ClusteredGroupedMorphologyLocations,
        ClusteredMorphologyLocations,
        ClusteredPathDistanceMorphologyLocations,
        PathDistanceMorphologyLocations,
    ] = Field(
        ...,
        description='Parameterization of locations on the neurites of the morphology',
        title='Morphology locations',
    )


class MorphologyMetricsForm(BaseModel):
    type: Literal['MorphologyMetricsForm'] = Field(..., title='Type')
    initialize: ObiOneScientificMorphologyMetricsMorphologyMetricsMorphologyMetricsFormInitialize


class MultiPulseCurrentClampSomaticStimulus(BaseModel):
    type: Literal['MultiPulseCurrentClampSomaticStimulus'] = Field(..., title='Type')
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    amplitude: Optional[Union[float, List[float]]] = Field(
        0.1,
        description='The amount of current initially injected when each pulse activates. Given in nA.',
        title='Amplitude',
    )
    width: Optional[Union[float, List[float]]] = Field(
        1,
        description='The length of time each pulse lasts. Given in ms.',
        title='Width',
    )
    frequency: Optional[Union[float, List[float]]] = Field(
        1, description='The frequency of pulse trains. Given in Hz.', title='Frequency'
    )


class NoiseCurrentClampSomaticStimulus(BaseModel):
    type: Literal['NoiseCurrentClampSomaticStimulus'] = Field(..., title='Type')
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    mean_amplitude: Optional[Union[float, List[float]]] = Field(
        0.01,
        description='The mean value of current to inject. Given in nA.',
        title='Mean Amplitude',
    )
    variance: Optional[Union[float, List[float]]] = Field(
        0.01,
        description='The variance around the mean of current to inject using a                     normal distribution.',
        title='Variance',
    )


class PercentageNoiseCurrentClampSomaticStimulus(BaseModel):
    type: Literal['PercentageNoiseCurrentClampSomaticStimulus'] = Field(
        ..., title='Type'
    )
    timestamps: RegularTimestamps
    simulation_level_name: Optional[constr(min_length=1)] = Field(
        None, title='Simulation Level Name'
    )
    delay: Optional[Union[float, List[float]]] = Field(
        0, description='Time in ms when input is activated.', title='Delay'
    )
    duration: Optional[Union[float, List[float]]] = Field(
        1,
        description='Time duration in ms for how long input is activated.',
        title='Duration',
    )
    neuron_set: Union[
        PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet
    ] = Field(
        ...,
        description='Neuron set to which the stimulus is applied.',
        title='Neuron Set',
    )
    represents_physical_electrode: Optional[bool] = Field(
        False,
        description='Default is False. If True, the signal will be implemented                         using a NEURON IClamp mechanism. The IClamp produce an                         electrode current which is not included in the calculation of                         extracellular signals, so this option should be used to                         represent a physical electrode. If the noise signal represents                         synaptic input, represents_physical_electrode should be set to                         False, in which case the signal will be implemented using a                         MembraneCurrentSource mechanism, which is identical to IClamp,                         but produce a membrane current, which is included in the                         calculation of the extracellular signal.',
        title='Represents Physical Electrode',
    )
    mean_percentage_of_threshold_current: Optional[Union[float, List[float]]] = Field(
        0.01,
        description="The mean value of current to inject as a percentage of a cell's                     threshold current.",
        title='Mean Percentage Of Threshold Current',
    )
    variance: Optional[Union[float, List[float]]] = Field(
        0.01,
        description='The variance around the mean of current to inject using a                     normal distribution.',
        title='Variance',
    )


class SimulationsForm(BaseModel):
    type: Literal['SimulationsForm'] = Field(..., title='Type')
    timestamps: Dict[str, RegularTimestamps] = Field(
        ..., description='Timestamps for the simulation', title='Timestamps'
    )
    stimuli: Dict[
        str,
        Union[
            SynchronousSingleSpikeStimulus,
            ConstantCurrentClampSomaticStimulus,
            LinearCurrentClampSomaticStimulus,
            RelativeConstantCurrentClampSomaticStimulus,
            MultiPulseCurrentClampSomaticStimulus,
            SinusoidalCurrentClampSomaticStimulus,
            SubthresholdCurrentClampSomaticStimulus,
            HyperpolarizingCurrentClampSomaticStimulus,
            NoiseCurrentClampSomaticStimulus,
            PercentageNoiseCurrentClampSomaticStimulus,
            RelativeLinearCurrentClampSomaticStimulus,
        ],
    ] = Field(..., title='Stimuli')
    recordings: Dict[str, SomaVoltageRecording] = Field(..., title='Recordings')
    neuron_sets: Dict[
        str,
        Union[PredefinedNeuronSet, CombinedNeuronSet, IDNeuronSet, PropertyNeuronSet],
    ] = Field(..., title='Neuron Sets')
    synapse_sets: Dict[str, IDSynapseSet] = Field(..., title='Synapse Sets')
    intracellular_location_sets: Dict[
        str,
        Union[
            MorphologyLocationsBlock,
            RandomGroupedMorphologyLocations,
            RandomMorphologyLocations,
            ClusteredGroupedMorphologyLocations,
            ClusteredMorphologyLocations,
            ClusteredPathDistanceMorphologyLocations,
            PathDistanceMorphologyLocations,
        ],
    ] = Field(..., title='Intracellular Location Sets')
    extracellular_location_sets: Dict[str, XYZExtracellularLocationSet] = Field(
        ..., title='Extracellular Location Sets'
    )
    initialize: ObiOneScientificSimulationSimulationsSimulationsFormInitialize


class SingleBlockEntityTestForm(BaseModel):
    type: Literal['SingleBlockEntityTestForm'] = Field(..., title='Type')
    initialize: (
        ObiOneScientificTestFormsTestFormSingleBlockSingleBlockEntityTestFormInitialize
    )


class SingleBlockGenerateTestForm(BaseModel):
    type: Literal['SingleBlockGenerateTestForm'] = Field(..., title='Type')
    initialize: ObiOneScientificTestFormsTestFormSingleBlockSingleBlockGenerateTestFormInitialize
