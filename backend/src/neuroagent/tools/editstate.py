"""Tool to edit the shared state using JSONPatch operations."""

import json
from typing import Any, ClassVar

import jsonpatch
from pydantic import BaseModel, Field

from neuroagent.new_types import SharedState
from neuroagent.tools.base_tool import BaseMetadata, BaseTool
from neuroagent.tools.autogenerated_types.obione import CircuitSimulationScanConfig


class JSONPatchOperation(BaseModel):
    """A single JSONPatch operation."""

    op: str = Field(
        description="Operation type: 'add', 'remove', 'replace', 'move', 'copy', or 'test'"
    )
    path: str = Field(
        description="JSONPointer path to the target location (e.g., '/smc_simulation_config/info/title')"
    )
    value: Any | None = Field(
        default=None,
        description="Value for add/replace/test operations. Not used for remove.",
    )
    from_: str | None = Field(
        default=None,
        alias="from",
        description="Source path for move/copy operations",
    )


class EditStateInput(BaseModel):
    """Input schema for the EditState tool."""

    patches: list[JSONPatchOperation] = Field(
        description="List of JSONPatch operations to apply to the state. Operations are applied sequentially."
    )


class EditStateMetadata(BaseMetadata):
    """Metadata for the EditState tool."""

    shared_state: SharedState


class EditStateOutput(BaseModel):
    """Output of the EditState tool."""

    state: SharedState = Field(
        description="The updated state after applying patches"
    )


_SHARED_STATE_SCHEMA = json.dumps(CircuitSimulationScanConfig.model_json_schema(), indent=2)


class EditStateTool(BaseTool):
    """Class defining the EditState tool."""

    name: ClassVar[str] = "editstate"
    name_frontend: ClassVar[str] = "Edit State"
    utterances: ClassVar[list[str]] = [
        "Update the configuration",
        "Modify the state",
        "Change the simulation parameters",
    ]
    description: ClassVar[str] = """Make incremental changes to the shared state using JSONPatch operations.

# Shared State Schema
""" + _SHARED_STATE_SCHEMA + """

# Key Concept: Work Incrementally
This tool modifies the state step-by-step. You can call it multiple times to build up complex changes gradually. There's no need to reset or replace the entire state - just apply the specific changes needed.

# CRITICAL: Always Validate After Editing
**MANDATORY:** Every set of state edits MUST end with a `validatestate` call. Never leave the state unvalidated after modifications.

If `validatestate` reports errors:
1. Use `editstate` to fix the specific issues incrementally
2. Call `validatestate` again
3. Repeat until the state is valid

# When to Use
- User requests state modifications ("change duration to 5000ms", "add a stimulus")
- `validatestate` reports errors that need fixing
- After `getstate` or receiving state from another tool output
- Building complex configurations step-by-step

# JSONPatch Operations
- **add**: Insert new value (creates parent objects if needed)
- **remove**: Delete a value
- **replace**: Change existing value
- **move**: Move value from one path to another
- **copy**: Copy value from one path to another
- **test**: Verify value before applying other operations

# Path Format (JSONPointer)
- `/smc_simulation_config/info/title` - nested objects
- `/smc_simulation_config/stimuli/my_stimulus` - dictionary keys
- `/smc_simulation_config/neuron_sets/0` - array indices

# Examples

Change duration:
```json
{"patches": [{"op": "replace", "path": "/smc_simulation_config/initialize/duration", "value": 5000.0}]}
```

Add stimulus:
```json
{"patches": [{"op": "add", "path": "/smc_simulation_config/stimuli/pulse", "value": {"type": "ConstantCurrentClampSomaticStimulus", "amplitude": 0.5}}]}
```

Fix validation error (missing required field):
```json
{"patches": [{"op": "add", "path": "/smc_simulation_config/info/description", "value": "My simulation"}]}
```

# Required Workflow
1. User requests change OR `validatestate` reports error
2. Call `editstate` with targeted patches to fix/modify
3. **ALWAYS call `validatestate`** to verify the changes
4. If errors remain, call `editstate` again with corrections
5. Repeat steps 3-4 until `validatestate` succeeds

# Best Practices
- Make small, focused changes per call
- Call multiple times for complex modifications
- **Never skip validation** - always end with `validatestate`
- Fix validation errors incrementally - don't reset the whole state
"""
    description_frontend: ClassVar[
        str
    ] = """Apply JSONPatch operations to modify the application state."""
    metadata: EditStateMetadata
    input_schema: EditStateInput

    async def arun(self) -> EditStateOutput:
        """Apply JSONPatch operations to the shared state."""
        if not self.metadata.shared_state:
            raise ValueError(
                "No shared state was provided in the request body.\n"
                "The editstate tool requires a state to modify."
            )

        # Get current state as dict
        current_state = self.metadata.shared_state.model_dump()

        # Validate patches before applying
        if not self.input_schema.patches:
            raise ValueError(
                "No patches provided.\n"
                "You must provide at least one JSONPatch operation.\n"
                "Example: [{\"op\": \"replace\", \"path\": \"/field\", \"value\": \"new_value\"}]"
            )

        # Convert patches to jsonpatch format
        patch_dicts = []
        for i, patch in enumerate(self.input_schema.patches, 1):
            # Validate patch structure
            if patch.op not in ["add", "remove", "replace", "move", "copy", "test"]:
                raise ValueError(
                    f"Patch operation #{i} has invalid operation: '{patch.op}'\n"
                    f"Valid operations: add, remove, replace, move, copy, test"
                )

            if not patch.path.startswith("/"):
                raise ValueError(
                    f"Patch operation #{i} has invalid path: '{patch.path}'\n"
                    f"Paths must start with '/' (JSONPointer format).\n"
                    f"Example: '/smc_simulation_config/initialize/duration'"
                )

            # Build patch dict
            patch_dict = {"op": patch.op, "path": patch.path}
            
            # Add value for operations that need it
            if patch.op in ["add", "replace", "test"]:
                if patch.value is None:
                    raise ValueError(
                        f"Patch operation #{i} ('{patch.op}') requires a 'value' field.\n"
                        f"Example: {{\"op\": \"{patch.op}\", \"path\": \"{patch.path}\", \"value\": ...}}"
                    )
                patch_dict["value"] = patch.value
            
            # Add from field for move/copy
            if patch.op in ["move", "copy"]:
                if not patch.from_:
                    raise ValueError(
                        f"Patch operation #{i} ('{patch.op}') requires a 'from' field.\n"
                        f"Example: {{\"op\": \"{patch.op}\", \"from\": \"/source/path\", \"path\": \"{patch.path}\"}}"
                    )
                patch_dict["from"] = patch.from_
            
            patch_dicts.append(patch_dict)

        # Apply patches
        try:
            patch = jsonpatch.JsonPatch(patch_dicts)
            updated_state = patch.apply(current_state)
        except jsonpatch.JsonPointerException as e:
            # Path doesn't exist
            error_msg = str(e)
            path_match = error_msg.split("'")
            failed_path = path_match[1] if len(path_match) > 1 else "unknown"
            
            # Try to provide helpful context
            path_parts = failed_path.strip("/").split("/")
            if len(path_parts) > 1:
                parent_path = "/" + "/".join(path_parts[:-1])
                try:
                    # Try to get parent to show available keys
                    parent = jsonpatch.resolve_pointer(current_state, parent_path)
                    if isinstance(parent, dict):
                        available_keys = list(parent.keys())
                        raise ValueError(
                            f"Cannot apply operation at path '{failed_path}'\n"
                            f"The path does not exist in the current state.\n\n"
                            f"Available keys at '{parent_path}':\n"
                            + "\n".join(f"  - {parent_path}/{key}" for key in available_keys[:10])
                            + ("\n  ... and more" if len(available_keys) > 10 else "")
                            + f"\n\nSuggestion: Check the path spelling or use 'add' operation to create new paths."
                        ) from e
                except:
                    pass
            
            raise ValueError(
                f"Cannot apply operation at path '{failed_path}'\n"
                f"The path does not exist in the current state.\n"
                f"Original error: {error_msg}\n\n"
                f"Suggestion: Use 'getstate' to see the current structure, then correct the path."
            ) from e
            
        except jsonpatch.JsonPatchConflict as e:
            # Test operation failed
            raise ValueError(
                f"Patch test operation failed: {str(e)}\n"
                f"The value at the specified path does not match the expected value.\n\n"
                f"Suggestion: Use 'getstate' to check the current value before applying patches."
            ) from e
            
        except jsonpatch.JsonPatchException as e:
            # Other patch errors
            error_msg = str(e)
            raise ValueError(
                f"Failed to apply patches: {error_msg}\n\n"
                f"This usually means:\n"
                f"  - Invalid operation for the target path\n"
                f"  - Type mismatch (e.g., trying to add to a non-dict/non-list)\n"
                f"  - Malformed patch structure\n\n"
                f"Suggestion: Review the patch operations and ensure they match the state structure."
            ) from e
            
        except (TypeError, KeyError, IndexError) as e:
            # Type or structure errors
            raise ValueError(
                f"Failed to apply patches due to type/structure error: {str(e)}\n\n"
                f"This usually means:\n"
                f"  - Trying to add to a non-dict/non-list\n"
                f"  - Index out of range for list operations\n"
                f"  - Type mismatch in the value\n\n"
                f"Suggestion: Use 'getstate' to verify the structure, then adjust your patches."
            ) from e
            
        except Exception as e:
            # Catch-all for unexpected errors
            raise ValueError(
                f"Unexpected error applying patches: {str(e)}\n"
                f"Error type: {type(e).__name__}\n\n"
                f"Suggestion: Review the patch operations and try again. "
                f"If the error persists, try breaking the changes into smaller patches."
            ) from e

        # Update the shared state in-place to maintain reference in context_variables
        try:
            # Validate the updated state can be parsed
            validated_state = SharedState(**updated_state)
            
            # Update the existing object's fields in-place
            for key, value in validated_state.model_dump().items():
                setattr(self.metadata.shared_state, key, value)
                
        except Exception as e:
            raise ValueError(
                f"Patches applied successfully, but the resulting state is invalid: {str(e)}\n\n"
                f"The state structure may be corrupted. Use 'validatestate' to see specific issues."
            ) from e

        return EditStateOutput(state=self.metadata.shared_state)

    @classmethod
    async def is_online(cls) -> bool:
        """Check if the tool is online."""
        return True
