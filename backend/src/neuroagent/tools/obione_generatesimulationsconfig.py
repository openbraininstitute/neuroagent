"""Tool to generate an obi-one compatible simulation config."""

from typing import ClassVar

from openai import AsyncOpenAI
from pydantic import BaseModel, Field
from pydantic.json_schema import SkipJsonSchema
from sqlalchemy.ext.asyncio import AsyncSession

from neuroagent.app.database.sql_schemas import State
from neuroagent.tools.autogenerated_types.obione import (
    CircuitFromID,
    ObiOneScientificSimulationSimulationsSimulationsFormInitialize,
    SimulationsForm,
)
from neuroagent.tools.base_tool import BaseMetadata, BaseTool
from neuroagent.utils import get_token_count


class GenerateSimulationsConfigInput(BaseModel):
    """Inputs of the GenerateSimulationsConfig tool."""

    circuit_id: str = Field(
        description="UUID of the target circuit that has to be simulated."
    )
    config_request: str = Field(
        description="Write a concise description (1–3 short sentences or compact bullets) of the desired simulation or change for the inner LLM to produce a simulation JSON. Include the objective, the scope/components, and only the parameters the user specified. The inner LLM may choose sensible defaults only for commonly expected fields — do not invent new parameter names nor specify imaginary actions (output path, simulator, parallelization etc...)."
    )


class GenerateSimulationsConfigMetadata(BaseMetadata):
    """Metadata of the GenerateSimulationsConfig tool."""

    openai_client: AsyncOpenAI
    state: State
    session: AsyncSession
    token_consumption: dict[str, str | int | None] | None = None


class InitializeNoCircuit(
    ObiOneScientificSimulationSimulationsSimulationsFormInitialize
):
    """Simulation Initialize block without reference to the circuit."""

    circuit: SkipJsonSchema[None] = Field(default=None, title="Circuit", exclude=True)  # type: ignore


class SimulationsFormModified(SimulationsForm):
    """Simulations form that redefines certain attributes."""

    initialize: InitializeNoCircuit = Field(
        ...,
        description="Parameters for initializing the simulation.",
        title="Initialization",
    )


class GenerateSimulationsConfigOutput(BaseModel):
    """Class holding the ordered list of json patchers to apply to the base config."""

    updated: bool = True


class GenerateSimulationsConfigTool(BaseTool):
    """Class defining the GenerateSimulationsConfig tool."""

    name: ClassVar[str] = "obione-generatesimulationsconfig"
    name_frontend: ClassVar[str] = "Generate Simulation Config"
    utterances: ClassVar[list[str]] = [
        "Create a simulation configuration",
        "Generate a config for me",
        "Set up simulation parameters",
    ]
    description: ClassVar[
        str
    ] = """This tool updates an internal JSON configurations for simulations based on natural language descriptions. It accepts both complete configuration specifications and modification requests for existing configurations, using an LLM with structured output to produce the corresponding JSON.
    Always use a circuit ID with this tool. If you can't see a reference to an existing circuit in the chat, ask for clarifications.
    if the user did not explicitly provide a circuit, he/she most likely is on the circuit page. Use the `context-analyzer-tool` to extract the circuit_id.

For modifications, you can provide incremental change descriptions - the tool will interpret these in the context of the existing configuration. You don't need to describe the entire final state; focused modification requests are fully supported.

Input: Either a comprehensive new configuration description OR specific modifications to an existing configuration.
Output: NONE. The tool updates internal states displayed in the frontend. Do not invent an output.

Use this tool when users need to:
- Create new configurations from scratch
- Modify, update, or tweak existing configurations
- Convert configuration requirements into structured JSON format

Always call this tool to generate a simulation config, never attempt to generate one yourself.
Do not try to generate a simulation config yourself if the tool fails.
Do not mention the new simulation config in the chat after running the tool. The update will be done directly in the frontend and exposed to the user. Simply state that the update had been done.
Do not propose "reasonable" parameters to the user unless you know for sure they are parameters that are being used here.
"""
    description_frontend: ClassVar[
        str
    ] = """Create or modify JSON configurations using natural language.
Simply specify in plain english what you want your configuration to achieve or what changes you would like to make."""
    metadata: GenerateSimulationsConfigMetadata
    input_schema: GenerateSimulationsConfigInput

    async def arun(self) -> GenerateSimulationsConfigOutput:
        """Run the tool."""
        smc_simulation_config = self.metadata.state
        if smc_simulation_config is None:
            raise ValueError("A state must be created fir the user.")
        initial_simulation_form = (
            smc_simulation_config.state[  # type: ignore
                "smc_simulation_config"  # Is None if doesn't exist. this is JSONB not python dict
            ]
            or {}
        )
        system_prompt = """# Simulation Configuration Generator

You are an expert at generating valid JSON simulation configurations following the SimulationsForm schema.
You will receive two inputs:
1. A description of the required configuration changes or specifications
2. The current simulation configuration JSON (either a default/empty config or an existing one)

## Task Approach
You are always modifying the provided configuration. The nature of modifications depends on the starting point:
- **Starting from default config**: User requests typically describe complete simulation requirements ("Generate a simulation with X neurons for Y duration")
- **Starting from existing config**: User requests typically describe incremental changes ("Add stimulus X", "Set parameter Y to Z")

Apply the requested changes to the provided configuration, replacing or adding elements as needed.

## Neuron Sets and References
- Generate neuron sets in the "neuron_sets" dictionary with meaningful keys
- **Only create neuron sets that will actually be used**
- For references (NeuronSetReference, TimestampsReference):
  - `block_name`: the dictionary key (e.g., "all_neurons")
  - `block_dict_name`: the parent dictionary name (e.g., "neuron_sets", "timestamps")
- Avoid duplicate or unused neuron sets unless specifically requested
- Replace or preserve existing neuron sets based on the modification request

## Timestamps and Stimuli Logic
- **Only generate timestamps if stimuli will use them**
- Choose stimulus type based on timing pattern:
  - **Single timestamp + MultiPulse**: For repeated pulses at one timepoint
  - **Multiple timestamps + single-pulse stimulus**: For stimuli at different timepoints
  - **Never combine MultiPulse with repetitive timestamps**
- Modify existing timing logic only when specifically requested

## Parameter Values
- Use single values, not single-element lists (e.g., `"duration": 500.0` not `"duration": [500.0]`)
- Lists indicate parameter sweeps - only use when scanning multiple values
- For IDNeuronSet, include meaningful number of neurons (typically 50+ for populations)
- Update only the parameters mentioned in the modification request

## Modification Guidelines
- **Comprehensive requests** (from default configs): Build out the full simulation as described, replacing default values
- **Incremental requests** (from existing configs): Make targeted changes while preserving unmodified elements
- "Add X" means include X alongside existing elements (unless it conflicts)
- "Remove" or "delete" means eliminate the specified element entirely
- "Set" or "change" means replace the specified parameter with the new value
- When building from defaults, interpret requests as comprehensive specifications rather than additions

## Validation Checklist
Before outputting, verify:
- [ ] All references use existing dictionary keys with correct block_dict_name
- [ ] No unused neuron sets or timestamps
- [ ] Stimulus timing logic is coherent
- [ ] No single-element lists unless intentional parameter sweep
- [ ] Requested changes are accurately applied to the provided configuration
- [ ] Configuration structure remains valid and consistent

Generate only the JSON configuration, ensuring all references are internally consistent.
"""

        user_message = f"""
CURRENT SIMULATION CONFIG JSON:
{initial_simulation_form}

REQUIREMENTS:
{self.input_schema.config_request}
"""

        model = "gpt-5-mini"
        # Then generate the global class and make the according references
        response = await self.metadata.openai_client.beta.chat.completions.parse(
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_message},
            ],
            model=model,
            reasoning_effort="medium",
            response_format=SimulationsFormModified,
        )
        if response.choices[0].message.parsed:
            # Get the output config
            config = response.choices[0].message.parsed

            # Gather everything in the OBI-One compatible class
            output_config = SimulationsForm(
                type="SimulationsForm",
                timestamps=config.timestamps or {},
                stimuli=config.stimuli or {},
                recordings=config.recordings or {},
                neuron_sets=config.neuron_sets or {},
                synaptic_manipulations=config.synaptic_manipulations or {},
                initialize=ObiOneScientificSimulationSimulationsSimulationsFormInitialize(
                    circuit=CircuitFromID(
                        id_str=self.input_schema.circuit_id, type="CircuitFromID"
                    ),
                    **config.initialize.model_dump(),
                ),
                info=config.info,
            )

            # Set the output back to the state
            self.metadata.state.state["smc_simulation_config"] = (  # type: ignore
                output_config.model_dump()
            )
            self.metadata.session.add(self.metadata.state)
            await self.metadata.session.commit()

            # Assign token usage
            token_consumption = get_token_count(response.usage)
            self.metadata.token_consumption = {**token_consumption, "model": model}
        else:
            raise ValueError("Couldn't generate a valid simulation config.")
        return GenerateSimulationsConfigOutput()

    @classmethod
    async def is_online(cls) -> bool:
        """Check if the tool is online."""
        return True
