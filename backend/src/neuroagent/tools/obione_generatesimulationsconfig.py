"""Tool to generate an obi-one compatible simulation config."""

from typing import ClassVar, Literal

from openai import AsyncOpenAI
from pydantic import BaseModel, Field

from neuroagent.new_types import SharedState
from neuroagent.tools.base_tool import BaseMetadata, BaseTool
from neuroagent.utils import get_token_count


class GenerateSimulationsConfigInput(BaseModel):
    """Inputs of the GenerateSimulationsConfig tool."""

    config_request: str = Field(
        description="Description of configuration changes to generate JSON PATCH operations. Specify either incremental modifications (delta) or complete configuration requirements."
    )


class GenerateSimulationsConfigMetadata(BaseMetadata):
    """Metadata of the GenerateSimulationsConfig tool."""

    openai_client: AsyncOpenAI
    shared_state: SharedState
    entity_frontend_url: str
    token_consumption: dict[str, str | int | None] | None = None


class JsonPatch(BaseModel):
    """Description of a single json patch operation."""

    op: Literal["add", "remove", "replace", "move", "copy", "test"] = Field(
        description="Operation to apply."
    )
    path: str = Field(
        description="Path in the original JSON where th apply the operation."
    )
    value: str | None = Field(
        description="Value that the operation applies at the given path."
    )


class JsonPatches(BaseModel):
    """Class holding the ordered list of json patchers to apply to the base config."""

    patches: list[JsonPatch]


class GenerateSimulationsConfigTool(BaseTool):
    """Class defining the GenerateSimulationsConfig tool."""

    name: ClassVar[str] = "obione-generatesimulationsconfig"
    name_frontend: ClassVar[str] = "Generate Simulation Config"
    utterances: ClassVar[list[str]] = [
        "Create a simulation configuration",
        "Generate a config for me",
        "Set up simulation parameters",
    ]
    description: ClassVar[
        str
    ] = """This tool generates JSON configurations for simulations based on natural language descriptions. It takes a user's request for a configuration (including modifications to existing configs) and uses an LLM with structured output to produce the corresponding JSON.
    Always use a circuit ID with this tool. If you can't see a reference to an existing circuit in the chat, ask for clarifications.
The tool is designed to handle both new configuration requests and modifications to existing configurations. When users request changes like "add feature X" or "remove setting Y", the tool requires a complete description of the desired final configuration state, not just the incremental changes.

Input: A comprehensive description of the desired configuration
Output: Structured JSON configuration generated by an LLM

Use this tool when users need to:
- Create new configurations from scratch
- Modify existing configurations
- Convert configuration requirements into structured JSON format

Always call this tool to generate a simulation config, never attempt to generate one yourself.
Do not try to generate a simulation config yourself if the tool fails.
    """
    description_frontend: ClassVar[
        str
    ] = """Create or modify JSON configurations using natural language.
Simply specify in plain english what you want your configuration to achieve or what changes you'd like to make."""
    metadata: GenerateSimulationsConfigMetadata
    input_schema: GenerateSimulationsConfigInput

    async def arun(self) -> JsonPatches:
        """Run the tool."""
        base_form = self.metadata.shared_state.smc_simulation_config
        if base_form is None:
            raise ValueError(
                f"To edit a Small Microcircuit Simulation, first navigate to {self.metadata.entity_frontend_url + '/simulate?&s=new&t=small-microcircuit'}, pick a circuit, click 'New Simulation' and call the tool again."
            )

        system_prompt = f"""# Simulation Configuration JSON PATCH Generator

You are an expert at generating JSON PATCH (RFC 6902) operations to modify existing simulation configurations following the SimulationsForm schema.
You will receive a base configuration JSON and a description of the required modifications as input.
Generate a JSON PATCH array that transforms the base configuration to meet the specified requirements.

## Critical Rules for JSON PATCH Generation

### Neuron Sets and References
- When adding neuron sets: use "add" operation with meaningful keys in "/neuron_sets"
- When modifying references (NeuronSetReference, TimestampsReference):
  - Ensure `block_name` matches existing or newly added dictionary keys
  - Ensure `block_dict_name` matches parent dictionary ("neuron_sets", "timestamps")
- Use "remove" operations to delete unused neuron sets
- **Only add neuron sets that will actually be used**

### Timestamps and Stimuli Logic
- **Only add timestamps if stimuli will use them**
- When modifying stimulus configurations, maintain timing pattern logic:
  - **Single timestamp + MultiPulse**: For repeated pulses at one timepoint
  - **Multiple timestamps + single-pulse stimulus**: For stimuli at different timepoints
  - **Never combine MultiPulse with repetitive timestamps**

### Parameter Values
- Use "replace" operations to change values to single values, not single-element lists
- Use "add" operations for lists only when creating intentional parameter sweeps
- For IDNeuronSet modifications, ensure meaningful neuron counts (typically 50+ for populations)

### JSON PATCH Operations
- Use minimal set of operations: prefer "replace" over "remove" + "add"
- Use proper JSON Pointer paths (e.g., "/neuron_sets/all_neurons", "/stimuli/0/duration")
- Validate that all path references exist in base config or are created by prior operations
- Order operations logically (create dependencies before references)

## Validation Checklist
Before outputting, verify:
- [ ] All path references are valid JSON Pointers
- [ ] Operations maintain reference consistency (block_name/block_dict_name)
- [ ] No operations create unused neuron sets or timestamps
- [ ] Stimulus timing logic remains coherent after patches
- [ ] Operations are ordered correctly (dependencies first)

Generate only the JSON PATCH array (list of operation objects with "op", "path", and "value" fields).
CURRENT JSON STATE:
{base_form.model_dump()}
"""
        model = "gpt-5-mini"
        # Then generate the global class and make the according references
        response = await self.metadata.openai_client.beta.chat.completions.parse(
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": self.input_schema.config_request},
            ],
            model=model,
            response_format=JsonPatches,
        )
        if response.choices[0].message.parsed:
            # Get the output config
            patches = response.choices[0].message.parsed
            # breakpoint()

            # Assign token usage
            token_consumption = get_token_count(response.usage)
            self.metadata.token_consumption = {**token_consumption, "model": model}
        else:
            raise ValueError("Couldn't generate valid json patches.")
        return patches

    @classmethod
    async def is_online(cls) -> bool:
        """Check if the tool is online."""
        return True
