"""Tool to generate an obi-one compatible simulation config."""

from typing import ClassVar

from openai import AsyncOpenAI
from pydantic import BaseModel, ConfigDict, Field
from pydantic.json_schema import SkipJsonSchema

from neuroagent.tools.autogenerated_types.obione import (
    AllNeurons,
    ExcitatoryNeurons,
    IDNeuronSet,
    InhibitoryNeurons,
    NbS1POmInputs,
    NbS1VPMInputs,
    NeuronSetReference,
    RegularTimestamps,
    SimulationsForm,
    SingleTimestamp,
    TimestampsReference,
)
from neuroagent.tools.base_tool import BaseMetadata, BaseTool
from neuroagent.utils import get_token_count


class GenerateSimulationsConfigInput(BaseModel):
    """Inputs of the GenerateSimulationsConfig tool."""

    config_request: str = Field(
        description="A complete description of the desired configuration that will be sent to an LLM for JSON generation. This should describe the ENTIRE configuration as it should exist after any requested changes, not just the modifications. For example, if a user says 'add X to my config' or 'remove Y from my config', translate this into a full description of what the complete configuration should contain, including all existing elements plus the requested additions or minus the requested removals."
    )


class GenerateSimulationsConfigMetadata(BaseMetadata):
    """Metadata of the GenerateSimulationsConfig tool."""

    openai_client: AsyncOpenAI
    token_consumption: dict[str, str | int | None] | None = None


class SimulationsFormModified(SimulationsForm):
    """Simulations form that redefines certain attributes."""

    timestamps: SkipJsonSchema[None] = Field(
        default=None,
        description="Timestamps for the simulation.",
        title="Timestamps",
        exclude=True,
    )
    neuron_sets: SkipJsonSchema[None] = Field(
        default=None,
        description="Neuron sets for the simulation.",
        title="Neuron Sets",
        exclude=True,
    )


class TimestampNeuronSets(BaseModel):
    """Pydantic class for generating timestamps via the LLM."""

    timestamps: dict[str, SingleTimestamp | RegularTimestamps] | None = Field(
        default=None,
        description="Timestamps for the simulation. The key of the dictionary must be a meaningful name.",
        title="Timestamps",
    )
    neuron_sets: (
        dict[
            str,
            IDNeuronSet
            | NbS1VPMInputs
            | NbS1POmInputs
            | AllNeurons
            | ExcitatoryNeurons
            | InhibitoryNeurons,
        ]
        | None
    ) = Field(
        default=None,
        description="Neuron sets for the simulation. The key of the dictionary must be a meaningful name. The first element should be the simulation target.",
        title="Neuron Sets",
    )
    model_config = ConfigDict(
        extra="ignore",
    )


def replace_type_recursively(
    obj: SimulationsFormModified,
    target_type: type[NeuronSetReference] | type[TimestampsReference],
    replacement: NeuronSetReference | TimestampsReference,
) -> SimulationsFormModified:
    if isinstance(obj, target_type):
        return replacement
    elif isinstance(obj, BaseModel):
        updated_fields = {
            k: replace_type_recursively(v, target_type, replacement)
            for k, v in obj.__dict__.items()
        }
        return obj.__class__(**updated_fields)
    elif isinstance(obj, list):
        return [
            replace_type_recursively(item, target_type, replacement) for item in obj
        ]
    elif isinstance(obj, dict):
        return {
            k: replace_type_recursively(v, target_type, replacement)
            for k, v in obj.items()
        }
    else:
        return obj


class GenerateSimulationsConfigTool(BaseTool):
    """Class defining the GenerateSimulationsConfig tool."""

    name: ClassVar[str] = "obi-one-generatesimulationsconfig"
    name_frontend: ClassVar[str] = "Generate Simulation Config"
    utterances: ClassVar[list[str]] = [
        "Create a simulation configuration",
        "Generate a config for me",
        "Set up simulation parameters",
    ]
    description: ClassVar[
        str
    ] = """This tool generates JSON configurations for simulations based on natural language descriptions. It takes a user's request for a configuration (including modifications to existing configs) and uses an LLM with structured output to produce the corresponding JSON.
The tool is designed to handle both new configuration requests and modifications to existing configurations. When users request changes like "add feature X" or "remove setting Y", the tool requires a complete description of the desired final configuration state, not just the incremental changes.

Input: A comprehensive description of the desired configuration
Output: Structured JSON configuration generated by an LLM

Use this tool when users need to:
- Create new configurations from scratch
- Modify existing configurations
- Convert configuration requirements into structured JSON format
    """
    description_frontend: ClassVar[
        str
    ] = """Create or modify JSON configurations using natural language.
Simply specify in plain english what you want your configuration to achieve or what changes you'd like to make."""
    metadata: GenerateSimulationsConfigMetadata
    input_schema: GenerateSimulationsConfigInput

    async def arun(self) -> SimulationsForm:
        """Run the tool."""
        system_prompt_timestamp_neuronset = """You are a configuration generation specialist for neuroscience simulations. Your task is to convert natural language descriptions of neuroscience circuit configurations into meaningful Timestamp and NeuronSets objects.
        The description of the configuration is going to be the first `user` message you receive.

**Your Role:**
- Take user descriptions of desired configurations and generate corresponding JSON
- Ensure the JSON is valid, properly formatted, and follows best practices
- Make reasonable assumptions for missing details based on common conventions
- Create complete, functional configurations that match the user's intent

**Guidelines:**
1. **JSON Structure**: Always output valid JSON with proper syntax, indentation, and data types
2. **Completeness**: Generate complete configurations, not partial snippets
3. **Best Practices**: Follow standard conventions for the type of configuration being requested
4. **Reasonable Defaults**: When specific values aren't provided, use sensible defaults appropriate for the context or keep the default provided in the output class
5. **Validation**: Ensure all required fields are present and values are appropriate for their intended use
6. **Extra Guideline**: Dictionary keys are going to be the name of the object. Make sure they are meaningful and unique.
7. **SImulation Target**: The first element of the `neuron_sets` dict must be the simulation target.

**Output Format:**
Respond ONLY with valid JSON. Do not include explanations, comments, or additional text outside the JSON structure.
"""
        system_prompt_sim_form = """You are a configuration generation specialist for neuroscience simulations. Your task is to convert natural language descriptions of configurations into well-structured JSON format.
        The description of the configuration is going to be the first `user` message you receive.

**Your Role:**
- Take user descriptions of desired configurations and generate corresponding JSON
- Ensure the JSON is valid, properly formatted, and follows best practices
- Make reasonable assumptions for missing details based on common conventions
- Create complete, functional configurations that match the user's intent

**Guidelines:**
1. **JSON Structure**: Always output valid JSON with proper syntax, indentation, and data types
2. **Completeness**: Generate complete configurations, not partial snippets
3. **Best Practices**: Follow standard conventions for the type of configuration being requested
4. **Reasonable Defaults**: When specific values aren't provided, use sensible defaults appropriate for the context or keep the default provided in the output class
5. **Validation**: Ensure all required fields are present and values are appropriate for their intended use

**Output Format:**
Respond ONLY with valid JSON. Do not include explanations, comments, or additional text outside the JSON structure.
"""
        model = "gpt-4o-mini"

        # OBI-one requires a two steps procedure: Generate stuff that can be refered to first
        response = await self.metadata.openai_client.beta.chat.completions.parse(
            messages=[
                {"role": "system", "content": system_prompt_timestamp_neuronset},
                {"role": "user", "content": self.input_schema.config_request},
            ],
            model=model,
            response_format=TimestampNeuronSets,
        )
        if response.choices[0].message.parsed:
            breakpoint()
            timestamps = response.choices[0].message.parsed.timestamps
            neuron_sets = response.choices[0].message.parsed.neuron_sets
            neuron_set_timestamps_usage = response.usage
        else:
            raise ValueError("Couldn't generate a valid simulation config.")

        # Then generate the global class and make the according references
        response = await self.metadata.openai_client.beta.chat.completions.parse(
            messages=[
                {"role": "system", "content": system_prompt_sim_form},
                {"role": "user", "content": self.input_schema.config_request},
            ],
            model=model,
            response_format=SimulationsFormModified,
        )
        if response.choices[0].message.parsed:
            # Get the output config
            config = response.choices[0].message.parsed
            breakpoint()
            config.neuron_sets = neuron_sets
            config.timestamps = timestamps
            neuron_set_reference = NeuronSetReference(
                block_name=neuron_sets.keys()[0], type="NeuronSetReference"
            )
            timestamps_reference = TimestampsReference(
                block_name=neuron_sets.keys()[0], type="TimestampsReference"
            )
            config = replace_type_recursively(
                obj=config,
                target_type=NeuronSetReference,
                replacement=neuron_set_reference,
            )
            config = replace_type_recursively(
                obj=config,
                target_type=TimestampsReference,
                replacement=timestamps_reference,
            )

            # Assign token usage
            total_usage = {
                k: neuron_set_timestamps_usage[k] + response.usage[k]
                for k in response.usage.keys()
            }
            token_consumption = get_token_count(total_usage)
            self.metadata.token_consumption = {**token_consumption, "model": model}
        else:
            raise ValueError("Couldn't generate a valid simulation config.")
        return config

    @classmethod
    async def is_online(cls) -> bool:
        """Check if the tool is online."""
        return True
